<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>TensorMol package &#8212; TensorMol 0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="TensorMol" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tensormol-package">
<h1>TensorMol package<a class="headerlink" href="#tensormol-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-TensorMol">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-TensorMol" title="Permalink to this headline">¶</a></h2>
<p>Code Conventions and Style Guide:</p>
<ul class="simple">
<li>USE HARD TABS. configure whatever editor you are using to use hard tabs.</li>
<li>UseCapitalizationToSeparateWords in names.</li>
<li>Prefer long interperable words to ambiguous abbreviations.</li>
<li>Avoid_the_underscore to separate words which takes longer to type than a cap.</li>
<li>The underscore is a good way to denote a function argument.</li>
<li>Keep functions to fewer than 5 parameters</li>
<li>Keep files and classes to &lt; 2000 lines.</li>
<li>Keep classes to &lt; 20 member variables.</li>
<li>Keep loops to a depth &lt; 6</li>
<li>Use functional programming constructs whenever possible.</li>
<li>Use docstrings, you asshole and use Args: and Returns:</li>
<li>Commit your changes once a day at least.</li>
<li>Use np.array rather than python list whenever possible.</li>
<li>It&#8217;s NOT okay to put default parameters in __init__() and change them all the time instead add them to TMPARAMS.py so they become logged parameters attached to results.</li>
<li>import TensorMol as tm; works as desired, don&#8217;t mess that up.</li>
</ul>
<p>Violators are subject to having their code and reproductive fitness mocked publically in comments.</p>
<dl class="class">
<dt id="TensorMol.Annealer">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Annealer</code><span class="sig-paren">(</span><em>f_</em>, <em>q_</em>, <em>g0_</em>, <em>name_='anneal'</em>, <em>AnnealThresh_=9e-06</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Annealer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.SimpleMD.IRTrajectory</span></code></p>
<dl class="method">
<dt id="TensorMol.Annealer.ForcesWithCharge">
<code class="descname">ForcesWithCharge</code><span class="sig-paren">(</span><em>x_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Annealer.ForcesWithCharge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Annealer.Prop">
<code class="descname">Prop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Annealer.Prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate VelocityVerlet</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Annealer.Pulse">
<code class="descname">Pulse</code><span class="sig-paren">(</span><em>t_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Annealer.Pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>delta pulse of duration</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Annealer.WriteTrajectory">
<code class="descname">WriteTrajectory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Annealer.WriteTrajectory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Annealer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>f_</em>, <em>q_</em>, <em>g0_</em>, <em>name_='anneal'</em>, <em>AnnealThresh_=9e-06</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Annealer.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Annealer.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.SimpleMD'</em><a class="headerlink" href="#TensorMol.Annealer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.AtomName_From_List">
<code class="descclassname">TensorMol.</code><code class="descname">AtomName_From_List</code><span class="sig-paren">(</span><em>atom_list</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomName_From_List" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="TensorMol.AtomNode">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">AtomNode</code><span class="sig-paren">(</span><em>node_type_=None</em>, <em>node_index_=None</em>, <em>undefined_bond_type_='any'</em>, <em>undefined_bond_=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Treat each atom as a node for the purpose of building the molecule graph</p>
<dl class="method">
<dt id="TensorMol.AtomNode.Append">
<code class="descname">Append</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomNode.Append" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.AtomNode.Connected_Atoms">
<code class="descname">Connected_Atoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomNode.Connected_Atoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.AtomNode.Num_of_Bonds">
<code class="descname">Num_of_Bonds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomNode.Num_of_Bonds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.AtomNode.Update_Node">
<code class="descname">Update_Node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomNode.Update_Node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.AtomNode.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>node_type_=None</em>, <em>node_index_=None</em>, <em>undefined_bond_type_='any'</em>, <em>undefined_bond_=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomNode.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.AtomNode.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.MolGraph'</em><a class="headerlink" href="#TensorMol.AtomNode.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.AtomicNumber">
<code class="descclassname">TensorMol.</code><code class="descname">AtomicNumber</code><span class="sig-paren">(</span><em>Symb</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomicNumber" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.AtomicSymbol">
<code class="descclassname">TensorMol.</code><code class="descname">AtomicSymbol</code><span class="sig-paren">(</span><em>number</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AtomicSymbol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.AutoCorrelation">
<code class="descclassname">TensorMol.</code><code class="descname">AutoCorrelation</code><span class="sig-paren">(</span><em>traj</em>, <em>step_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.AutoCorrelation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="TensorMol.BFGS">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">BFGS</code><span class="sig-paren">(</span><em>m_</em>, <em>ForceAndEnergy_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.BFGS" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.BFGS.NextStep">
<code class="descname">NextStep</code><span class="sig-paren">(</span><em>new_vec_</em>, <em>new_residual_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.BFGS.NextStep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.BFGS.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>m_</em>, <em>ForceAndEnergy_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.BFGS.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplest Possible BFGS</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.BFGS.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.BFGS'</em><a class="headerlink" href="#TensorMol.BFGS.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Basis">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Basis</code><span class="sig-paren">(</span><em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.Basis.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Basis.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Basis.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Basis.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Basis'</em><a class="headerlink" href="#TensorMol.Basis.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Basis_GauSH">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Basis_GauSH</code><span class="sig-paren">(</span><em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis_GauSH" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.Basis.Basis</span></code></p>
<dl class="method">
<dt id="TensorMol.Basis_GauSH.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis_GauSH.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Basis_GauSH.Orthogonalize">
<code class="descname">Orthogonalize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis_GauSH.Orthogonalize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Basis_GauSH.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis_GauSH.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Basis_GauSH.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Basis_GauSH.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Basis_GauSH.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Basis'</em><a class="headerlink" href="#TensorMol.Basis_GauSH.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.Binominal_Combination">
<code class="descclassname">TensorMol.</code><code class="descname">Binominal_Combination</code><span class="sig-paren">(</span><em>indis=[0, 1, 2], group=3</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Binominal_Combination" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.BruteForceAtoms">
<code class="descclassname">TensorMol.</code><code class="descname">BruteForceAtoms</code><span class="sig-paren">(</span><em>mol_</em>, <em>dig_</em>, <em>emb_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.BruteForceAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.CartToSphere">
<code class="descclassname">TensorMol.</code><code class="descname">CartToSphere</code><span class="sig-paren">(</span><em>arg_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.CartToSphere" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.CartToSphereV">
<code class="descclassname">TensorMol.</code><code class="descname">CartToSphereV</code><span class="sig-paren">(</span><em>arg_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.CartToSphereV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.CenterOfMass">
<code class="descclassname">TensorMol.</code><code class="descname">CenterOfMass</code><span class="sig-paren">(</span><em>x_</em>, <em>m_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.CenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.ChargeCharge">
<code class="descclassname">TensorMol.</code><code class="descname">ChargeCharge</code><span class="sig-paren">(</span><em>m1_</em>, <em>m2_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.ChargeCharge" title="Permalink to this definition">¶</a></dt>
<dd><p>calcuate  the charge-charge interaction energy between two molecules</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.CoordinateScan">
<code class="descclassname">TensorMol.</code><code class="descname">CoordinateScan</code><span class="sig-paren">(</span><em>f_</em>, <em>x_</em>, <em>name_=''</em>, <em>eps_=0.03</em>, <em>num_=15</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.CoordinateScan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.CosKernelLR">
<code class="descclassname">TensorMol.</code><code class="descname">CosKernelLR</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.CosKernelLR" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;Cos&#8217; =&gt; 1/r -&gt; (1-0.5*(cos(PI*r/EECutoff)+1))/r (if r&gt;Cutoff else 0)
:param D: A square distance matrix (bohr)
:param Long: Whether long range or short range</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.CosKernelSR">
<code class="descclassname">TensorMol.</code><code class="descname">CosKernelSR</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.CosKernelSR" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8216;Cos&#8217; =&gt; 1/r -&gt; (1-0.5*(cos(PI*r/EECutoff)+1))/r (if r&gt;Cutoff else 0)
:param D: A square distance matrix (bohr)
:param Long: Whether long range or short range</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.CosSoftCut">
<code class="descclassname">TensorMol.</code><code class="descname">CosSoftCut</code><span class="sig-paren">(</span><em>dist</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.CosSoftCut" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.CoulombKernel">
<code class="descclassname">TensorMol.</code><code class="descname">CoulombKernel</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.CoulombKernel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>D</strong> &#8211; A square distance matrix (bohr)</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;EESwitchFunc&quot;</strong><strong>]</strong><strong></strong> &#8211; The Kernel type
None =&gt; 1/r, bare Coulomb
&#8216;Cos&#8217; =&gt; 1/r -&gt; (0.5*(cos(PI*r/EECutoff)+1))/r (if r&gt;Cutoff else 0)
&#8216;Tanh&#8217; =&gt; 1/r =&gt; 0.5*(Tanh[(x - EECutoff)/EEdr] + 1)/r</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="TensorMol.DIIS">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">DIIS</code><a class="headerlink" href="#TensorMol.DIIS" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.DIIS.NextStep">
<code class="descname">NextStep</code><span class="sig-paren">(</span><em>new_vec_</em>, <em>new_residual_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.DIIS.NextStep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.DIIS.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.DIIS.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Simplest Possible DIIS</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.DIIS.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.DIIS'</em><a class="headerlink" href="#TensorMol.DIIS.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.DiagHess">
<code class="descclassname">TensorMol.</code><code class="descname">DiagHess</code><span class="sig-paren">(</span><em>f_</em>, <em>x_</em>, <em>eps_=0.0005</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.DiagHess" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>returns -1*gradient.</strong> (<em>f</em>) &#8211; </li>
<li><strong>a guess</strong> (<em>x</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="TensorMol.Digester">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Digester</code><span class="sig-paren">(</span><em>eles_</em>, <em>name_='GauSH'</em>, <em>OType_='Disp'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester" title="Permalink to this definition">¶</a></dt>
<dd><p>An Embedding gives some chemical description of a molecular
Environment around a point. This one is for networks that will embed properties of atoms.
please refer to /C_API/setup.py</p>
<p>note: Molecule embeddings and Behler-Parrinello are in DigestMol.</p>
<dl class="method">
<dt id="TensorMol.Digester.Blurs">
<code class="descname">Blurs</code><span class="sig-paren">(</span><em>diffs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.Blurs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.Emb">
<code class="descname">Emb</code><span class="sig-paren">(</span><em>mol_</em>, <em>at_</em>, <em>xyz_</em>, <em>MakeOutputs=True</em>, <em>MakeGradients=False</em>, <em>Transforms=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.Emb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates various molecular embeddings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol</strong> &#8211; a Molecule to be digested</li>
<li><strong>at</strong> &#8211; an atom to be digested or moved. if <a href="#id1"><span class="problematic" id="id2">at_</span></a> &lt; 0 it usually returns arrays for each atom in the molecule</li>
<li><strong>xyz</strong> &#8211; makes inputs with <a href="#id3"><span class="problematic" id="id4">at_</span></a> moved to these positions.</li>
<li><strong>MakeOutputs</strong> &#8211; generates outputs according to self.OType.</li>
<li><strong>MakeGradients</strong> &#8211; Generate nuclear derivatives of inputs.</li>
<li><strong>Transforms</strong> &#8211; Generate inputs for all the linear transformations appended.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Output embeddings, and possibly labels and gradients.
if <a href="#id5"><span class="problematic" id="id6">at_</span></a> &lt; 0 the first dimension loops over atoms in <a href="#id7"><span class="problematic" id="id8">mol_</span></a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.HardCut">
<code class="descname">HardCut</code><span class="sig-paren">(</span><em>diffs</em>, <em>cutoff=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.HardCut" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.MakeSamples_v2">
<code class="descname">MakeSamples_v2</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.MakeSamples_v2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.Print">
<code class="descname">Print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.Print" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.SampleDigestWPyscf">
<code class="descname">SampleDigestWPyscf</code><span class="sig-paren">(</span><em>mol_</em>, <em>ele_</em>, <em>uniform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.SampleDigestWPyscf" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs PySCF calculations for each sample without generating embeddings and probabilities</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.TrainDigest">
<code class="descname">TrainDigest</code><span class="sig-paren">(</span><em>mol_</em>, <em>ele_</em>, <em>MakeDebug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.TrainDigest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of inputs and outputs for a molecule.
Uses self.Emb() uses Mol to get the Desired output type (Energy,Force,Probability etc.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mol</strong> &#8211; a molecule to be digested</li>
<li><strong>ele</strong> &#8211; an element for which training data will be made.</li>
<li><strong>MakeDebug</strong> &#8211; if MakeDebug is True, it also returns a list with debug information to trace possible errors in digestion.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.TrainDigestMolwise">
<code class="descname">TrainDigestMolwise</code><span class="sig-paren">(</span><em>mol_</em>, <em>MakeOutputs_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.TrainDigestMolwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of inputs and outputs for a molecule.
Uses self.Emb() uses Mol to get the Desired output type (Energy,Force,Probability etc.)
This version works mol-wise to try to speed up and avoid calling C++ so much...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol</strong> &#8211; a molecule to be digested</li>
<li><strong>eles</strong> &#8211; A list of elements coming from Tensordata to order the output.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">containing inputs and outputs in order of <a href="#id9"><span class="problematic" id="id10">eles_</span></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">Two lists</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.UniformDigest">
<code class="descname">UniformDigest</code><span class="sig-paren">(</span><em>mol_</em>, <em>at_</em>, <em>mxstep</em>, <em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.UniformDigest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of inputs sampled on a uniform cubic grid around at</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>eles_</em>, <em>name_='GauSH'</em>, <em>OType_='Disp'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>eles</strong> &#8211; a list of elements in the Tensordata that I&#8217;ll digest</li>
<li><strong>name</strong> &#8211; type of digester to reduce molecules to NN inputs.</li>
<li><strong>OType</strong> &#8211; property of the molecule which will be learned (energy, force, etc)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.Digester.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Digest'</em><a class="headerlink" href="#TensorMol.Digester.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.emb_vary_coords">
<code class="descname">emb_vary_coords</code><span class="sig-paren">(</span><em>coords</em>, <em>xyz</em>, <em>atoms</em>, <em>eles</em>, <em>Radius</em>, <em>ngrid</em>, <em>vary_at</em>, <em>tar_at</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.emb_vary_coords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.make_pgaussian">
<code class="descname">make_pgaussian</code><span class="sig-paren">(</span><em>coords_</em>, <em>xyz_</em>, <em>ats_</em>, <em>eles_</em>, <em>SensRadius</em>, <em>ngrid</em>, <em>at_</em>, <em>dummy</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.make_pgaussian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Digester.make_sym">
<code class="descname">make_sym</code><span class="sig-paren">(</span><em>coords_</em>, <em>xyz_</em>, <em>ats_</em>, <em>eles</em>, <em>SensRadius</em>, <em>ngrid</em>, <em>at_</em>, <em>dummy</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Digester.make_sym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.Dihed_4Points">
<code class="descclassname">TensorMol.</code><code class="descname">Dihed_4Points</code><span class="sig-paren">(</span><em>x1</em>, <em>x2</em>, <em>x3</em>, <em>x4</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Dihed_4Points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.Dipole">
<code class="descclassname">TensorMol.</code><code class="descname">Dipole</code><span class="sig-paren">(</span><em>x_</em>, <em>q_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Dipole" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments are in A, and elementary charges.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.DipoleDebug">
<code class="descclassname">TensorMol.</code><code class="descname">DipoleDebug</code><span class="sig-paren">(</span><em>m_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.DipoleDebug" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.DirectedFdiffHessian">
<code class="descclassname">TensorMol.</code><code class="descname">DirectedFdiffHessian</code><span class="sig-paren">(</span><em>f_</em>, <em>x_</em>, <em>dirs_</em>, <em>eps_=0.01</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.DirectedFdiffHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Four-Point Hessian quadrature along <a href="#id11"><span class="problematic" id="id12">dirs_</span></a> directions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dirs</strong> &#8211; a set of directions having <a href="#id13"><span class="problematic" id="id14">x_</span></a>&#8216;s shape</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">d^2 f/ (d dirs_i, d dirs_j)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.ECoulECutoff">
<code class="descclassname">TensorMol.</code><code class="descname">ECoulECutoff</code><span class="sig-paren">(</span><em>m_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.ECoulECutoff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.ElectricFieldForce">
<code class="descclassname">TensorMol.</code><code class="descname">ElectricFieldForce</code><span class="sig-paren">(</span><em>q_</em>, <em>E_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.ElectricFieldForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Both are received in atomic units.
The force should be returned in kg(m/s)^2, but I haven&#8217;t fixed the units yet.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.EmbAtomwiseErr">
<code class="descclassname">TensorMol.</code><code class="descname">EmbAtomwiseErr</code><span class="sig-paren">(</span><em>mol_</em>, <em>dig_</em>, <em>emb_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.EmbAtomwiseErr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="TensorMol.EmbeddingOptimizer">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">EmbeddingOptimizer</code><span class="sig-paren">(</span><em>method_</em>, <em>set_</em>, <em>dig_</em>, <em>OType_=None</em>, <em>Elements_=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.EmbeddingOptimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides an objective function to optimize an embedding, maximizing the reversibility of the embedding, and the distance the embedding predicts between molecules which are not equivalent in their geometry or stoiciometry.</p>
<dl class="method">
<dt id="TensorMol.EmbeddingOptimizer.Ipecac_Objective">
<code class="descname">Ipecac_Objective</code><span class="sig-paren">(</span><em>basisParams_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.EmbeddingOptimizer.Ipecac_Objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the parameters. Builds the overlap if neccesary. Resets the desired embeddings. Reverses the distorted set and computes an error.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.EmbeddingOptimizer.KRR_Objective">
<code class="descname">KRR_Objective</code><span class="sig-paren">(</span><em>basisParams_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.EmbeddingOptimizer.KRR_Objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the parameters. Builds the overlap if neccesary. Resets the desired embeddings. Reverses the distorted set and computes an error.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.EmbeddingOptimizer.PerformOptimization">
<code class="descname">PerformOptimization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.EmbeddingOptimizer.PerformOptimization" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.EmbeddingOptimizer.SetBasisParams">
<code class="descname">SetBasisParams</code><span class="sig-paren">(</span><em>basisParams_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.EmbeddingOptimizer.SetBasisParams" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.EmbeddingOptimizer.SetEmbeddings">
<code class="descname">SetEmbeddings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.EmbeddingOptimizer.SetEmbeddings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.EmbeddingOptimizer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>method_</em>, <em>set_</em>, <em>dig_</em>, <em>OType_=None</em>, <em>Elements_=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.EmbeddingOptimizer.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.EmbeddingOptimizer.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.EmbOpt'</em><a class="headerlink" href="#TensorMol.EmbeddingOptimizer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.ErfSoftCut">
<code class="descclassname">TensorMol.</code><code class="descname">ErfSoftCut</code><span class="sig-paren">(</span><em>dist</em>, <em>width</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.ErfSoftCut" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.FdiffGradient">
<code class="descclassname">TensorMol.</code><code class="descname">FdiffGradient</code><span class="sig-paren">(</span><em>f_</em>, <em>x_</em>, <em>eps_=0.0001</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FdiffGradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a finite difference gradient of a single or multi-valued function
at <a href="#id15"><span class="problematic" id="id16">x_</span></a> for debugging purposes.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.FdiffHessian">
<code class="descclassname">TensorMol.</code><code class="descname">FdiffHessian</code><span class="sig-paren">(</span><em>f_</em>, <em>x_</em>, <em>eps_=0.0001</em>, <em>mode_='central'</em>, <em>grad_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FdiffHessian" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes a finite difference hessian of a single or multi-valued function
at <a href="#id17"><span class="problematic" id="id18">x_</span></a> for debugging purposes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> &#8211; objective function of <a href="#id19"><span class="problematic" id="id20">x_</span></a></li>
<li><strong>x</strong> &#8211; point at which derivative is taken.</li>
<li><strong>eps</strong> &#8211; finite difference step</li>
<li><strong>mode</strong> &#8211; forward, central, or gradient Differences</li>
<li><strong>grad</strong> &#8211; a gradient function if available.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.FourPointHessQuad">
<code class="descclassname">TensorMol.</code><code class="descname">FourPointHessQuad</code><span class="sig-paren">(</span><em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FourPointHessQuad" title="Permalink to this definition">¶</a></dt>
<dd><p>f is a 4x4xOutshape
sampling eps*[-2, -1, 1, 2]</p>
</dd></dl>

<dl class="class">
<dt id="TensorMol.Frag">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Frag</code><span class="sig-paren">(</span><em>atoms_=None</em>, <em>coords_=None</em>, <em>index_=None</em>, <em>dist_=None</em>, <em>atom_group_=1</em>, <em>frag_type_=None</em>, <em>frag_type_index_=None</em>, <em>FragOrder_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.Mol.Mol</span></code></p>
<p>Provides a MBE frag of general purpose cluster</p>
<dl class="method">
<dt id="TensorMol.Frag.AddPointstoMolDots">
<code class="descname">AddPointstoMolDots</code><span class="sig-paren">(</span><em>grids</em>, <em>points</em>, <em>value</em>, <em>ngrids=250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.AddPointstoMolDots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.AlignAtoms">
<code class="descname">AlignAtoms</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.AlignAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Align the geometries and atom order of myself and another molecule.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.AllAtomNames">
<code class="descname">AllAtomNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.AllAtomNames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.AtomName">
<code class="descname">AtomName</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.AtomName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.AtomsWithin">
<code class="descname">AtomsWithin</code><span class="sig-paren">(</span><em>rad</em>, <em>pt</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.AtomsWithin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.BuildDistanceMatrix">
<code class="descname">BuildDistanceMatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.BuildDistanceMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.CalculateAtomization">
<code class="descname">CalculateAtomization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.CalculateAtomization" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Calculate_vdw">
<code class="descname">Calculate_vdw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Calculate_vdw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Center">
<code class="descname">Center</code><span class="sig-paren">(</span><em>CenterOf='Atom'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of atom or mass</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Combine_CM_NN_Deri">
<code class="descname">Combine_CM_NN_Deri</code><span class="sig-paren">(</span><em>cm_deri</em>, <em>nn_deri</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Combine_CM_NN_Deri" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.CopyTo">
<code class="descname">CopyTo</code><span class="sig-paren">(</span><em>target</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.CopyTo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Distort">
<code class="descname">Distort</code><span class="sig-paren">(</span><em>disp=0.38</em>, <em>movechance=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Distort" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly distort my coords, but save eq. coords first</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.DistortAN">
<code class="descname">DistortAN</code><span class="sig-paren">(</span><em>movechance=0.15</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.DistortAN" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly replace atom types.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.EnergiesOfAtomMoves">
<code class="descname">EnergiesOfAtomMoves</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.EnergiesOfAtomMoves" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.EnergyAfterAtomMove">
<code class="descname">EnergyAfterAtomMove</code><span class="sig-paren">(</span><em>s</em>, <em>i</em>, <em>Type='GO'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.EnergyAfterAtomMove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Energy_from_xyz">
<code class="descname">Energy_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Energy_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the energy from the comment line in the md_dataset.
Switched on by has_energy=True in the ReadGDB9Unpacked routine</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.FitGoProb">
<code class="descname">FitGoProb</code><span class="sig-paren">(</span><em>ii</em>, <em>Print=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.FitGoProb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a Go-potential for atom i on a uniform grid of 4A with 50 pts/direction
And fits that go potential with the H&#64;0 basis centered at the same point
In practice 9 (1A) gaussians separated on a 1A grid around the sensory point appears to work for moderate distortions.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Force_from_xyz">
<code class="descname">Force_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Force_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the forces from the comment line in the md_dataset,
and if no forces exist sets them to zero. Switched on by
has_force=True in the ReadGDB9Unpacked routine</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Frag_Force">
<code class="descname">Frag_Force</code><span class="sig-paren">(</span><em>cm_deri</em>, <em>nn_deri</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Frag_Force" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Frag_MBE_Energy">
<code class="descname">Frag_MBE_Energy</code><span class="sig-paren">(</span><em>index=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Frag_MBE_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.FromXYZString">
<code class="descname">FromXYZString</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.FromXYZString" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Get_Qchem_Frag_MBE_Energy">
<code class="descname">Get_Qchem_Frag_MBE_Energy</code><span class="sig-paren">(</span><em>order</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Get_Qchem_Frag_MBE_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Get_Qchem_Frag_MBE_Energy_All">
<code class="descname">Get_Qchem_Frag_MBE_Energy_All</code><span class="sig-paren">(</span><em>fragnum</em>, <em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Get_Qchem_Frag_MBE_Energy_All" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.GoEnergy">
<code class="descname">GoEnergy</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.GoEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths. This is the lennard jones soft version</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.GoForce">
<code class="descname">GoForce</code><span class="sig-paren">(</span><em>at_=-1</em>, <em>spherical=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.GoForce" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths, and this is the force of that potential.
Args: <a href="#id21"><span class="problematic" id="id22">at_</span></a> an atom index, if <a href="#id23"><span class="problematic" id="id24">at_</span></a> = -1 it returns an array for each atom.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.GoForceLocal">
<code class="descname">GoForceLocal</code><span class="sig-paren">(</span><em>at_=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.GoForceLocal" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths, and this is the force of that potential.
A MUCH FASTER VERSION OF THIS ROUTINE IS NOW AVAILABLE, see MolEmb::Make_Go</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.GoForce_Scan">
<code class="descname">GoForce_Scan</code><span class="sig-paren">(</span><em>maxstep</em>, <em>ngrid</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.GoForce_Scan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.GoHessian">
<code class="descname">GoHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.GoHessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.IsIsomer">
<code class="descname">IsIsomer</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.IsIsomer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.MMFF94_Force_from_xyz">
<code class="descname">MMFF94_Force_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.MMFF94_Force_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the forces from the comment line in the md_dataset,
and if no forces exist sets them to zero. Switched on by
has_force=True in the ReadGDB9Unpacked routine
TODO: Move this out of Mol please to AbInitio (JAP)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Make_Spherical_Forces">
<code class="descname">Make_Spherical_Forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Make_Spherical_Forces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.MolDots">
<code class="descname">MolDots</code><span class="sig-paren">(</span><em>ngrids=250</em>, <em>padding=2.0</em>, <em>width=2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.MolDots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.MolGrids">
<code class="descname">MolGrids</code><span class="sig-paren">(</span><em>ngrids=250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.MolGrids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.MultipoleInputs">
<code class="descname">MultipoleInputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.MultipoleInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>These are the quantities (in Atomic Units)
which you multiply the atomic charges by (and sum)
in order to calculate the multipoles of a molecule
up to PARAMS[&#8220;EEOrder&#8221;]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">(NAtoms X (monopole, dipole x, ... quad x... etc. ))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.NEles">
<code class="descname">NEles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.NEles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.NumOfAtomsE">
<code class="descname">NumOfAtomsE</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.NumOfAtomsE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Num_of_Heavy_Atom">
<code class="descname">Num_of_Heavy_Atom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Num_of_Heavy_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.NumericGoHessian">
<code class="descname">NumericGoHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.NumericGoHessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.OverlapEmbeddings">
<code class="descname">OverlapEmbeddings</code><span class="sig-paren">(</span><em>d1</em>, <em>coords</em>, <em>d2</em>, <em>d3</em>, <em>d4</em>, <em>d5</em>, <em>i</em>, <em>d6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.OverlapEmbeddings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.POfAtomMoves">
<code class="descname">POfAtomMoves</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.POfAtomMoves" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments are given relative to the coordinate of i</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.PySCFEnergyAfterAtomMove">
<code class="descname">PySCFEnergyAfterAtomMove</code><span class="sig-paren">(</span><em>s</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.PySCFEnergyAfterAtomMove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.PySCF_Energy">
<code class="descname">PySCF_Energy</code><span class="sig-paren">(</span><em>basis_='cc-pvqz'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.PySCF_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.PySCF_Frag_MBE_Energy">
<code class="descname">PySCF_Frag_MBE_Energy</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.PySCF_Frag_MBE_Energy" title="Permalink to this definition">¶</a></dt>
<dd><p># Below is the old version of PySCF_Frag_MBE_Energy, not working for General MBE, needs to be rewritten, KY</p>
<p>inner_index = range(0, self.FragOrder)
real_frag_index=list(itertools.combinations(inner_index,order))
ghost_frag_index=[]
for i in range (0, len(real_frag_index)):</p>
<blockquote>
<div>ghost_frag_index.append(list(set(inner_index)-set(real_frag_index[i])))</div></blockquote>
<p>i =0
while(i&lt; len(real_frag_index)):</p>
<blockquote>
<div><p>#for i in range (0, len(real_frag_index)):
pyscfatomstring=&#8221;&#8221;
mol = gto.Mole()
for j in range (0, order):</p>
<blockquote>
<div><dl class="docutils">
<dt>for k in range (0, self.atom_group):</dt>
<dd>s = self.coords[real_frag_index[i][j]*self.atom_group+k]
pyscfatomstring=pyscfatomstring+str(self.AtomName(real_frag_index[i][j]*self.atom_group+k))+&#8221; &#8220;+str(s[0])+&#8221; &#8220;+str(s[1])+&#8221; &#8220;+str(s[2])+&#8221;;&#8221;</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>for j in range (0, self.FragOrder - order):</dt>
<dd><dl class="first last docutils">
<dt>for k in range (0, self.atom_group):</dt>
<dd>s = self.coords[ghost_frag_index[i][j]*self.atom_group+k]
pyscfatomstring=pyscfatomstring+&#8221;GHOST&#8221;+str(j*self.atom_group+k)+&#8221; &#8220;+str(s[0])+&#8221; &#8220;+str(s[1])+&#8221; &#8220;+str(s[2])+&#8221;;&#8221;</dd>
</dl>
</dd>
</dl>
<p>pyscfatomstring=pyscfatomstring[:-1]+&#8221;  &#8221;
mol.atom =pyscfatomstring</p>
<p>mol.basis ={}
ele_set = list(set(self.AllAtomNames()))
for ele in ele_set:</p>
<blockquote>
<div>mol.basis[str(ele)]=&#8221;cc-pvqz&#8221;</div></blockquote>
<dl class="docutils">
<dt>for j in range (0, self.FragOrder - order):</dt>
<dd><dl class="first last docutils">
<dt>for k in range (0, self.atom_group):</dt>
<dd>atom_type = self.AtomName(ghost_frag_index[i][j]*self.atom_group+k)
mol.basis[&#8216;GHOST&#8217;+str(j*self.atom_group+k)]=gto.basis.load(&#8216;cc-pvqz&#8217;,str(atom_type))</dd>
</dl>
</dd>
</dl>
<p>mol.verbose=0
try:</p>
<blockquote>
<div>print &#8220;doing case &#8221;, i
time_log = time.time()
mol.build()
mf=scf.RHF(mol)
hf_en = mf.kernel()
mp2 = mp.MP2(mf)
mp2_en = mp2.kernel()
en = hf_en + mp2_en[0]
#print &#8220;hf_en&#8221;, hf_en, &#8220;mp2_en&#8221;, mp2_en[0], &#8221; en&#8221;, en
self.frag_mbe_energies[LtoS(real_frag_index[i])]=en
print (&#8220;pyscf time..&#8221;, time.time()-time_log)
i = i+1
gc.collect()</div></blockquote>
<dl class="docutils">
<dt>except Exception as Ex:</dt>
<dd>print &#8220;PYSCF Calculation error... :&#8221;,Ex
print &#8220;Mol.atom:&#8221;, mol.atom
print &#8220;Pyscf string:&#8221;, pyscfatomstring</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.PySCF_Frag_MBE_Energy_All">
<code class="descname">PySCF_Frag_MBE_Energy_All</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.PySCF_Frag_MBE_Energy_All" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.ReadGDB9">
<code class="descname">ReadGDB9</code><span class="sig-paren">(</span><em>path</em>, <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.ReadGDB9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>axis</em>, <em>ang</em>, <em>origin=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atomic coordinates and forces if present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> &#8211; vector for rotation axis</li>
<li><strong>ang</strong> &#8211; radians of rotation</li>
<li><strong>origin</strong> &#8211; origin of rotation axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.RotateRandomUniform">
<code class="descname">RotateRandomUniform</code><span class="sig-paren">(</span><em>randnums=None</em>, <em>origin=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.RotateRandomUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atomic coordinates and forces if present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>randnums</strong> &#8211; theta, phi, and z for rotation, if None then rotation is random</li>
<li><strong>origin</strong> &#8211; origin of rotation axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.RunPySCFWithCoords">
<code class="descname">RunPySCFWithCoords</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.RunPySCFWithCoords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.ScanNormalModes">
<code class="descname">ScanNormalModes</code><span class="sig-paren">(</span><em>npts=11</em>, <em>disp=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.ScanNormalModes" title="Permalink to this definition">¶</a></dt>
<dd><p>These modes are normal</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Set_EQ_force">
<code class="descname">Set_EQ_force</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Set_EQ_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets forces to 0 for equilibrium molecules with no force data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Set_Frag_MBE_Energy">
<code class="descname">Set_Frag_MBE_Energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Set_Frag_MBE_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Set_Qchem_Data_Path">
<code class="descname">Set_Qchem_Data_Path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Set_Qchem_Data_Path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.SoftCutGoForce">
<code class="descname">SoftCutGoForce</code><span class="sig-paren">(</span><em>cutdist=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.SoftCutGoForce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.SoftCutGoForceOneAtom">
<code class="descname">SoftCutGoForceOneAtom</code><span class="sig-paren">(</span><em>at_</em>, <em>cutdist=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.SoftCutGoForceOneAtom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.SortAtoms">
<code class="descname">SortAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.SortAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>First sorts by element, then sorts by distance to the center of the molecule
This improves alignment.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.SpanningGrid">
<code class="descname">SpanningGrid</code><span class="sig-paren">(</span><em>num=250</em>, <em>pad=4.0</em>, <em>Flatten=True</em>, <em>Cubic=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.SpanningGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a regular grid the molecule fits into</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Transform">
<code class="descname">Transform</code><span class="sig-paren">(</span><em>ltransf</em>, <em>center=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.UseGoProb">
<code class="descname">UseGoProb</code><span class="sig-paren">(</span><em>ii</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.UseGoProb" title="Permalink to this definition">¶</a></dt>
<dd><p>The opposite of the routine above. It takes the digested probability vectors and uses it to calculate desired new positions.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.WriteInterpolation">
<code class="descname">WriteInterpolation</code><span class="sig-paren">(</span><em>b</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.WriteInterpolation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.WriteSmiles">
<code class="descname">WriteSmiles</code><span class="sig-paren">(</span><em>fpath='.'</em>, <em>fname='gdb9_smiles'</em>, <em>mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.WriteSmiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.WriteXYZfile">
<code class="descname">WriteXYZfile</code><span class="sig-paren">(</span><em>fpath='.'</em>, <em>fname='mol'</em>, <em>mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.WriteXYZfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Write_Qchem_Frag_MBE_Input_All">
<code class="descname">Write_Qchem_Frag_MBE_Input_All</code><span class="sig-paren">(</span><em>fragnum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Write_Qchem_Frag_MBE_Input_All" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Write_Qchem_Frag_MBE_Input_All_General">
<code class="descname">Write_Qchem_Frag_MBE_Input_All_General</code><span class="sig-paren">(</span><em>fragnum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Write_Qchem_Frag_MBE_Input_All_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.Write_Qchem_Frag_MBE_Input_General">
<code class="descname">Write_Qchem_Frag_MBE_Input_General</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.Write_Qchem_Frag_MBE_Input_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.XYZtoGridIndex">
<code class="descname">XYZtoGridIndex</code><span class="sig-paren">(</span><em>xyz</em>, <em>ngrids=250</em>, <em>padding=2.0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.XYZtoGridIndex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>atoms_=None</em>, <em>coords_=None</em>, <em>index_=None</em>, <em>dist_=None</em>, <em>atom_group_=1</em>, <em>frag_type_=None</em>, <em>frag_type_index_=None</em>, <em>FragOrder_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Frag.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.MolFrag'</em><a class="headerlink" href="#TensorMol.Frag.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian coordinate difference.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag.rms_inv">
<code class="descname">rms_inv</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag.rms_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Invariant coordinate difference.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Frag_of_Mol">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Frag_of_Mol</code><span class="sig-paren">(</span><em>atoms_=None</em>, <em>coords_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.Mol.Mol</span></code></p>
<dl class="method">
<dt id="TensorMol.Frag_of_Mol.AddPointstoMolDots">
<code class="descname">AddPointstoMolDots</code><span class="sig-paren">(</span><em>grids</em>, <em>points</em>, <em>value</em>, <em>ngrids=250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.AddPointstoMolDots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.AlignAtoms">
<code class="descname">AlignAtoms</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.AlignAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Align the geometries and atom order of myself and another molecule.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.AllAtomNames">
<code class="descname">AllAtomNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.AllAtomNames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.AtomName">
<code class="descname">AtomName</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.AtomName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.AtomsWithin">
<code class="descname">AtomsWithin</code><span class="sig-paren">(</span><em>rad</em>, <em>pt</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.AtomsWithin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.BuildDistanceMatrix">
<code class="descname">BuildDistanceMatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.BuildDistanceMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.CalculateAtomization">
<code class="descname">CalculateAtomization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.CalculateAtomization" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Calculate_vdw">
<code class="descname">Calculate_vdw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Calculate_vdw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Center">
<code class="descname">Center</code><span class="sig-paren">(</span><em>CenterOf='Atom'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of atom or mass</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Distort">
<code class="descname">Distort</code><span class="sig-paren">(</span><em>disp=0.38</em>, <em>movechance=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Distort" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly distort my coords, but save eq. coords first</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.DistortAN">
<code class="descname">DistortAN</code><span class="sig-paren">(</span><em>movechance=0.15</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.DistortAN" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly replace atom types.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.EnergiesOfAtomMoves">
<code class="descname">EnergiesOfAtomMoves</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.EnergiesOfAtomMoves" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.EnergyAfterAtomMove">
<code class="descname">EnergyAfterAtomMove</code><span class="sig-paren">(</span><em>s</em>, <em>i</em>, <em>Type='GO'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.EnergyAfterAtomMove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Energy_from_xyz">
<code class="descname">Energy_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Energy_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the energy from the comment line in the md_dataset.
Switched on by has_energy=True in the ReadGDB9Unpacked routine</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.FitGoProb">
<code class="descname">FitGoProb</code><span class="sig-paren">(</span><em>ii</em>, <em>Print=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.FitGoProb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a Go-potential for atom i on a uniform grid of 4A with 50 pts/direction
And fits that go potential with the H&#64;0 basis centered at the same point
In practice 9 (1A) gaussians separated on a 1A grid around the sensory point appears to work for moderate distortions.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Force_from_xyz">
<code class="descname">Force_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Force_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the forces from the comment line in the md_dataset,
and if no forces exist sets them to zero. Switched on by
has_force=True in the ReadGDB9Unpacked routine</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.FromXYZString">
<code class="descname">FromXYZString</code><span class="sig-paren">(</span><em>string</em>, <em>set_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.FromXYZString" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.GoEnergy">
<code class="descname">GoEnergy</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.GoEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths. This is the lennard jones soft version</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.GoForce">
<code class="descname">GoForce</code><span class="sig-paren">(</span><em>at_=-1</em>, <em>spherical=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.GoForce" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths, and this is the force of that potential.
Args: <a href="#id25"><span class="problematic" id="id26">at_</span></a> an atom index, if <a href="#id27"><span class="problematic" id="id28">at_</span></a> = -1 it returns an array for each atom.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.GoForceLocal">
<code class="descname">GoForceLocal</code><span class="sig-paren">(</span><em>at_=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.GoForceLocal" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths, and this is the force of that potential.
A MUCH FASTER VERSION OF THIS ROUTINE IS NOW AVAILABLE, see MolEmb::Make_Go</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.GoForce_Scan">
<code class="descname">GoForce_Scan</code><span class="sig-paren">(</span><em>maxstep</em>, <em>ngrid</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.GoForce_Scan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.GoHessian">
<code class="descname">GoHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.GoHessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.IsIsomer">
<code class="descname">IsIsomer</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.IsIsomer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.MMFF94_Force_from_xyz">
<code class="descname">MMFF94_Force_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.MMFF94_Force_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the forces from the comment line in the md_dataset,
and if no forces exist sets them to zero. Switched on by
has_force=True in the ReadGDB9Unpacked routine
TODO: Move this out of Mol please to AbInitio (JAP)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Make_AtomNodes">
<code class="descname">Make_AtomNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Make_AtomNodes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Make_Spherical_Forces">
<code class="descname">Make_Spherical_Forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Make_Spherical_Forces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.MolDots">
<code class="descname">MolDots</code><span class="sig-paren">(</span><em>ngrids=250</em>, <em>padding=2.0</em>, <em>width=2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.MolDots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.MolGrids">
<code class="descname">MolGrids</code><span class="sig-paren">(</span><em>ngrids=250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.MolGrids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.MultipoleInputs">
<code class="descname">MultipoleInputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.MultipoleInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>These are the quantities (in Atomic Units)
which you multiply the atomic charges by (and sum)
in order to calculate the multipoles of a molecule
up to PARAMS[&#8220;EEOrder&#8221;]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">(NAtoms X (monopole, dipole x, ... quad x... etc. ))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.NEles">
<code class="descname">NEles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.NEles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.NumOfAtomsE">
<code class="descname">NumOfAtomsE</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.NumOfAtomsE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Num_of_Heavy_Atom">
<code class="descname">Num_of_Heavy_Atom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Num_of_Heavy_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.NumericGoHessian">
<code class="descname">NumericGoHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.NumericGoHessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.OverlapEmbeddings">
<code class="descname">OverlapEmbeddings</code><span class="sig-paren">(</span><em>d1</em>, <em>coords</em>, <em>d2</em>, <em>d3</em>, <em>d4</em>, <em>d5</em>, <em>i</em>, <em>d6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.OverlapEmbeddings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.POfAtomMoves">
<code class="descname">POfAtomMoves</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.POfAtomMoves" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments are given relative to the coordinate of i</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.PySCFEnergyAfterAtomMove">
<code class="descname">PySCFEnergyAfterAtomMove</code><span class="sig-paren">(</span><em>s</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.PySCFEnergyAfterAtomMove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.PySCF_Energy">
<code class="descname">PySCF_Energy</code><span class="sig-paren">(</span><em>basis_='cc-pvqz'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.PySCF_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.ReadGDB9">
<code class="descname">ReadGDB9</code><span class="sig-paren">(</span><em>path</em>, <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.ReadGDB9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>axis</em>, <em>ang</em>, <em>origin=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atomic coordinates and forces if present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> &#8211; vector for rotation axis</li>
<li><strong>ang</strong> &#8211; radians of rotation</li>
<li><strong>origin</strong> &#8211; origin of rotation axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.RotateRandomUniform">
<code class="descname">RotateRandomUniform</code><span class="sig-paren">(</span><em>randnums=None</em>, <em>origin=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.RotateRandomUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atomic coordinates and forces if present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>randnums</strong> &#8211; theta, phi, and z for rotation, if None then rotation is random</li>
<li><strong>origin</strong> &#8211; origin of rotation axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.RunPySCFWithCoords">
<code class="descname">RunPySCFWithCoords</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.RunPySCFWithCoords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.ScanNormalModes">
<code class="descname">ScanNormalModes</code><span class="sig-paren">(</span><em>npts=11</em>, <em>disp=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.ScanNormalModes" title="Permalink to this definition">¶</a></dt>
<dd><p>These modes are normal</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Set_EQ_force">
<code class="descname">Set_EQ_force</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Set_EQ_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets forces to 0 for equilibrium molecules with no force data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Set_Qchem_Data_Path">
<code class="descname">Set_Qchem_Data_Path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Set_Qchem_Data_Path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.SoftCutGoForce">
<code class="descname">SoftCutGoForce</code><span class="sig-paren">(</span><em>cutdist=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.SoftCutGoForce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.SoftCutGoForceOneAtom">
<code class="descname">SoftCutGoForceOneAtom</code><span class="sig-paren">(</span><em>at_</em>, <em>cutdist=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.SoftCutGoForceOneAtom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.SortAtoms">
<code class="descname">SortAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.SortAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>First sorts by element, then sorts by distance to the center of the molecule
This improves alignment.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.SpanningGrid">
<code class="descname">SpanningGrid</code><span class="sig-paren">(</span><em>num=250</em>, <em>pad=4.0</em>, <em>Flatten=True</em>, <em>Cubic=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.SpanningGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a regular grid the molecule fits into</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.Transform">
<code class="descname">Transform</code><span class="sig-paren">(</span><em>ltransf</em>, <em>center=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.Transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.UseGoProb">
<code class="descname">UseGoProb</code><span class="sig-paren">(</span><em>ii</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.UseGoProb" title="Permalink to this definition">¶</a></dt>
<dd><p>The opposite of the routine above. It takes the digested probability vectors and uses it to calculate desired new positions.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.WriteInterpolation">
<code class="descname">WriteInterpolation</code><span class="sig-paren">(</span><em>b</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.WriteInterpolation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.WriteSmiles">
<code class="descname">WriteSmiles</code><span class="sig-paren">(</span><em>fpath='.'</em>, <em>fname='gdb9_smiles'</em>, <em>mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.WriteSmiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.WriteXYZfile">
<code class="descname">WriteXYZfile</code><span class="sig-paren">(</span><em>fpath='.'</em>, <em>fname='mol'</em>, <em>mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.WriteXYZfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.XYZtoGridIndex">
<code class="descname">XYZtoGridIndex</code><span class="sig-paren">(</span><em>xyz</em>, <em>ngrids=250</em>, <em>padding=2.0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.XYZtoGridIndex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>atoms_=None</em>, <em>coords_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Frag_of_Mol.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Mol'</em><a class="headerlink" href="#TensorMol.Frag_of_Mol.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian coordinate difference.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_Mol.rms_inv">
<code class="descname">rms_inv</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_Mol.rms_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Invariant coordinate difference.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Frag_of_MolGraph">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Frag_of_MolGraph</code><span class="sig-paren">(</span><em>mol_</em>, <em>undefined_bonds_=None</em>, <em>undefined_bond_type_=None</em>, <em>bond_length_thresh_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.MolGraph.MolGraph</span></code></p>
<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.AllAtomNames">
<code class="descname">AllAtomNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.AllAtomNames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.AtomName">
<code class="descname">AtomName</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.AtomName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.BondTypes">
<code class="descname">BondTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.BondTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Calculate_Bond_Type">
<code class="descname">Calculate_Bond_Type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Calculate_Bond_Type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Check_Connection">
<code class="descname">Check_Connection</code><span class="sig-paren">(</span><em>mol_node</em>, <em>frag_node</em>, <em>mol_visited_list</em>, <em>frag_visited_list</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Check_Connection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Compare_Node">
<code class="descname">Compare_Node</code><span class="sig-paren">(</span><em>mol_node</em>, <em>frag_node</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Compare_Node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Connect_AtomNodes">
<code class="descname">Connect_AtomNodes</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Connect_AtomNodes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Find_Bond_Index">
<code class="descname">Find_Bond_Index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Find_Bond_Index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Find_Frag">
<code class="descname">Find_Frag</code><span class="sig-paren">(</span><em>frag, ignored_ele=[1], frag_head=0, avail_atoms=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Find_Frag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.FromXYZString">
<code class="descname">FromXYZString</code><span class="sig-paren">(</span><em>string</em>, <em>set_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.FromXYZString" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.GetNextNode_DFS">
<code class="descname">GetNextNode_DFS</code><span class="sig-paren">(</span><em>visited_list</em>, <em>node_stack</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.GetNextNode_DFS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.IsIsomer">
<code class="descname">IsIsomer</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.IsIsomer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Make_AtomNodes">
<code class="descname">Make_AtomNodes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Make_AtomNodes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Make_Bonds">
<code class="descname">Make_Bonds</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Make_Bonds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.Make_Mol_Graph">
<code class="descname">Make_Mol_Graph</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.Make_Mol_Graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.NBonds">
<code class="descname">NBonds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.NBonds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Frag_of_MolGraph.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>mol_</em>, <em>undefined_bonds_=None</em>, <em>undefined_bond_type_=None</em>, <em>bond_length_thresh_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Frag_of_MolGraph.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.MolGraph'</em><a class="headerlink" href="#TensorMol.Frag_of_MolGraph.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.FragableCluster">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">FragableCluster</code><span class="sig-paren">(</span><em>atoms_=None</em>, <em>coords_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.Mol.Mol</span></code></p>
<p>Provides a cluster which can be fragmented into molecules</p>
<dl class="method">
<dt id="TensorMol.FragableCluster.AddPointstoMolDots">
<code class="descname">AddPointstoMolDots</code><span class="sig-paren">(</span><em>grids</em>, <em>points</em>, <em>value</em>, <em>ngrids=250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.AddPointstoMolDots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.AlignAtoms">
<code class="descname">AlignAtoms</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.AlignAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Align the geometries and atom order of myself and another molecule.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.AllAtomNames">
<code class="descname">AllAtomNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.AllAtomNames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.AtomName">
<code class="descname">AtomName</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.AtomName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.AtomsWithin">
<code class="descname">AtomsWithin</code><span class="sig-paren">(</span><em>rad</em>, <em>pt</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.AtomsWithin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.BuildDistanceMatrix">
<code class="descname">BuildDistanceMatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.BuildDistanceMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.CalculateAtomization">
<code class="descname">CalculateAtomization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.CalculateAtomization" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Calculate_All_Frag_Energy_General">
<code class="descname">Calculate_All_Frag_Energy_General</code><span class="sig-paren">(</span><em>method='pyscf'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Calculate_All_Frag_Energy_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Calculate_Frag_Energy_General">
<code class="descname">Calculate_Frag_Energy_General</code><span class="sig-paren">(</span><em>order</em>, <em>method='pyscf'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Calculate_Frag_Energy_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Calculate_vdw">
<code class="descname">Calculate_vdw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Calculate_vdw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Center">
<code class="descname">Center</code><span class="sig-paren">(</span><em>CenterOf='Atom'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of atom or mass</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Distort">
<code class="descname">Distort</code><span class="sig-paren">(</span><em>disp=0.38</em>, <em>movechance=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Distort" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly distort my coords, but save eq. coords first</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.DistortAN">
<code class="descname">DistortAN</code><span class="sig-paren">(</span><em>movechance=0.15</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.DistortAN" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly replace atom types.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.EnergiesOfAtomMoves">
<code class="descname">EnergiesOfAtomMoves</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.EnergiesOfAtomMoves" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.EnergyAfterAtomMove">
<code class="descname">EnergyAfterAtomMove</code><span class="sig-paren">(</span><em>s</em>, <em>i</em>, <em>Type='GO'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.EnergyAfterAtomMove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Energy_from_xyz">
<code class="descname">Energy_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Energy_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the energy from the comment line in the md_dataset.
Switched on by has_energy=True in the ReadGDB9Unpacked routine</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.FitGoProb">
<code class="descname">FitGoProb</code><span class="sig-paren">(</span><em>ii</em>, <em>Print=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.FitGoProb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a Go-potential for atom i on a uniform grid of 4A with 50 pts/direction
And fits that go potential with the H&#64;0 basis centered at the same point
In practice 9 (1A) gaussians separated on a 1A grid around the sensory point appears to work for moderate distortions.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Force_from_xyz">
<code class="descname">Force_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Force_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the forces from the comment line in the md_dataset,
and if no forces exist sets them to zero. Switched on by
has_force=True in the ReadGDB9Unpacked routine</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.FromXYZString">
<code class="descname">FromXYZString</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.FromXYZString" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Generate_All_MBE_term_General">
<code class="descname">Generate_All_MBE_term_General</code><span class="sig-paren">(</span><em>frag_list=[]</em>, <em>cutoff=10</em>, <em>center_atom=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Generate_All_MBE_term_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Generate_All_Pairs">
<code class="descname">Generate_All_Pairs</code><span class="sig-paren">(</span><em>pair_list=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Generate_All_Pairs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Generate_MBE_term_General">
<code class="descname">Generate_MBE_term_General</code><span class="sig-paren">(</span><em>order</em>, <em>cutoff=10</em>, <em>center_atom=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Generate_MBE_term_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Get_All_Qchem_Frag_Energy_General">
<code class="descname">Get_All_Qchem_Frag_Energy_General</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Get_All_Qchem_Frag_Energy_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Get_Qchem_Frag_Energy">
<code class="descname">Get_Qchem_Frag_Energy</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Get_Qchem_Frag_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.GoEnergy">
<code class="descname">GoEnergy</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.GoEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths. This is the lennard jones soft version</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.GoForce">
<code class="descname">GoForce</code><span class="sig-paren">(</span><em>at_=-1</em>, <em>spherical=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.GoForce" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths, and this is the force of that potential.
Args: <a href="#id29"><span class="problematic" id="id30">at_</span></a> an atom index, if <a href="#id31"><span class="problematic" id="id32">at_</span></a> = -1 it returns an array for each atom.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.GoForceLocal">
<code class="descname">GoForceLocal</code><span class="sig-paren">(</span><em>at_=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.GoForceLocal" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths, and this is the force of that potential.
A MUCH FASTER VERSION OF THIS ROUTINE IS NOW AVAILABLE, see MolEmb::Make_Go</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.GoForce_Scan">
<code class="descname">GoForce_Scan</code><span class="sig-paren">(</span><em>maxstep</em>, <em>ngrid</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.GoForce_Scan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.GoHessian">
<code class="descname">GoHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.GoHessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.IsIsomer">
<code class="descname">IsIsomer</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.IsIsomer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.MBE">
<code class="descname">MBE</code><span class="sig-paren">(</span><em>atom_group=1</em>, <em>cutoff=10</em>, <em>center_atom=0</em>, <em>max_case=1000000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.MBE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.MMFF94_Force_from_xyz">
<code class="descname">MMFF94_Force_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.MMFF94_Force_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the forces from the comment line in the md_dataset,
and if no forces exist sets them to zero. Switched on by
has_force=True in the ReadGDB9Unpacked routine
TODO: Move this out of Mol please to AbInitio (JAP)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Make_Spherical_Forces">
<code class="descname">Make_Spherical_Forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Make_Spherical_Forces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.MolDots">
<code class="descname">MolDots</code><span class="sig-paren">(</span><em>ngrids=250</em>, <em>padding=2.0</em>, <em>width=2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.MolDots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.MolGrids">
<code class="descname">MolGrids</code><span class="sig-paren">(</span><em>ngrids=250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.MolGrids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.MultipoleInputs">
<code class="descname">MultipoleInputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.MultipoleInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>These are the quantities (in Atomic Units)
which you multiply the atomic charges by (and sum)
in order to calculate the multipoles of a molecule
up to PARAMS[&#8220;EEOrder&#8221;]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">(NAtoms X (monopole, dipole x, ... quad x... etc. ))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.NEles">
<code class="descname">NEles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.NEles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.NumOfAtomsE">
<code class="descname">NumOfAtomsE</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.NumOfAtomsE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Num_of_Heavy_Atom">
<code class="descname">Num_of_Heavy_Atom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Num_of_Heavy_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.NumericGoHessian">
<code class="descname">NumericGoHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.NumericGoHessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.OverlapEmbeddings">
<code class="descname">OverlapEmbeddings</code><span class="sig-paren">(</span><em>d1</em>, <em>coords</em>, <em>d2</em>, <em>d3</em>, <em>d4</em>, <em>d5</em>, <em>i</em>, <em>d6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.OverlapEmbeddings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.POfAtomMoves">
<code class="descname">POfAtomMoves</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.POfAtomMoves" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments are given relative to the coordinate of i</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.PairUp">
<code class="descname">PairUp</code><span class="sig-paren">(</span><em>dic_mono</em>, <em>dic_mono_index</em>, <em>pair</em>, <em>happy_atoms</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.PairUp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.PySCFEnergyAfterAtomMove">
<code class="descname">PySCFEnergyAfterAtomMove</code><span class="sig-paren">(</span><em>s</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.PySCFEnergyAfterAtomMove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.PySCF_Energy">
<code class="descname">PySCF_Energy</code><span class="sig-paren">(</span><em>basis_='cc-pvqz'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.PySCF_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.ReadGDB9">
<code class="descname">ReadGDB9</code><span class="sig-paren">(</span><em>path</em>, <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.ReadGDB9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Reset_Frags">
<code class="descname">Reset_Frags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Reset_Frags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>axis</em>, <em>ang</em>, <em>origin=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atomic coordinates and forces if present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> &#8211; vector for rotation axis</li>
<li><strong>ang</strong> &#8211; radians of rotation</li>
<li><strong>origin</strong> &#8211; origin of rotation axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.RotateRandomUniform">
<code class="descname">RotateRandomUniform</code><span class="sig-paren">(</span><em>randnums=None</em>, <em>origin=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.RotateRandomUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atomic coordinates and forces if present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>randnums</strong> &#8211; theta, phi, and z for rotation, if None then rotation is random</li>
<li><strong>origin</strong> &#8211; origin of rotation axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.RunPySCFWithCoords">
<code class="descname">RunPySCFWithCoords</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.RunPySCFWithCoords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.ScanNormalModes">
<code class="descname">ScanNormalModes</code><span class="sig-paren">(</span><em>npts=11</em>, <em>disp=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.ScanNormalModes" title="Permalink to this definition">¶</a></dt>
<dd><p>These modes are normal</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Set_EQ_force">
<code class="descname">Set_EQ_force</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Set_EQ_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets forces to 0 for equilibrium molecules with no force data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Set_Frag_Force_with_Order">
<code class="descname">Set_Frag_Force_with_Order</code><span class="sig-paren">(</span><em>cm_deri</em>, <em>nn_deri</em>, <em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Set_Frag_Force_with_Order" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Set_MBE_Energy">
<code class="descname">Set_MBE_Energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Set_MBE_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Set_MBE_Force">
<code class="descname">Set_MBE_Force</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Set_MBE_Force" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Set_Qchem_Data_Path">
<code class="descname">Set_Qchem_Data_Path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Set_Qchem_Data_Path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.SoftCutGoForce">
<code class="descname">SoftCutGoForce</code><span class="sig-paren">(</span><em>cutdist=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.SoftCutGoForce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.SoftCutGoForceOneAtom">
<code class="descname">SoftCutGoForceOneAtom</code><span class="sig-paren">(</span><em>at_</em>, <em>cutdist=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.SoftCutGoForceOneAtom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.SortAtoms">
<code class="descname">SortAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.SortAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>First sorts by element, then sorts by distance to the center of the molecule
This improves alignment.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Sort_frag_list">
<code class="descname">Sort_frag_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Sort_frag_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.SpanningGrid">
<code class="descname">SpanningGrid</code><span class="sig-paren">(</span><em>num=250</em>, <em>pad=4.0</em>, <em>Flatten=True</em>, <em>Cubic=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.SpanningGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a regular grid the molecule fits into</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Transform">
<code class="descname">Transform</code><span class="sig-paren">(</span><em>ltransf</em>, <em>center=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.UseGoProb">
<code class="descname">UseGoProb</code><span class="sig-paren">(</span><em>ii</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.UseGoProb" title="Permalink to this definition">¶</a></dt>
<dd><p>The opposite of the routine above. It takes the digested probability vectors and uses it to calculate desired new positions.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.WriteInterpolation">
<code class="descname">WriteInterpolation</code><span class="sig-paren">(</span><em>b</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.WriteInterpolation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.WriteSmiles">
<code class="descname">WriteSmiles</code><span class="sig-paren">(</span><em>fpath='.'</em>, <em>fname='gdb9_smiles'</em>, <em>mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.WriteSmiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.WriteXYZfile">
<code class="descname">WriteXYZfile</code><span class="sig-paren">(</span><em>fpath='.'</em>, <em>fname='mol'</em>, <em>mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.WriteXYZfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.Write_Qchem_Submit_Script">
<code class="descname">Write_Qchem_Submit_Script</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.Write_Qchem_Submit_Script" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.XYZtoGridIndex">
<code class="descname">XYZtoGridIndex</code><span class="sig-paren">(</span><em>xyz</em>, <em>ngrids=250</em>, <em>padding=2.0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.XYZtoGridIndex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>atoms_=None</em>, <em>coords_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.FragableCluster.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.MolFrag'</em><a class="headerlink" href="#TensorMol.FragableCluster.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian coordinate difference.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableCluster.rms_inv">
<code class="descname">rms_inv</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableCluster.rms_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Invariant coordinate difference.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.FragableClusterBF">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">FragableClusterBF</code><span class="sig-paren">(</span><em>atoms_=None</em>, <em>coords_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.Mol.Mol</span></code></p>
<p>All the monomers can pair with each other, no cutoff</p>
<dl class="method">
<dt id="TensorMol.FragableClusterBF.AddPointstoMolDots">
<code class="descname">AddPointstoMolDots</code><span class="sig-paren">(</span><em>grids</em>, <em>points</em>, <em>value</em>, <em>ngrids=250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.AddPointstoMolDots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.AlignAtoms">
<code class="descname">AlignAtoms</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.AlignAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Align the geometries and atom order of myself and another molecule.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.AllAtomNames">
<code class="descname">AllAtomNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.AllAtomNames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.AtomName">
<code class="descname">AtomName</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.AtomName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.AtomsWithin">
<code class="descname">AtomsWithin</code><span class="sig-paren">(</span><em>rad</em>, <em>pt</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.AtomsWithin" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.BuildDistanceMatrix">
<code class="descname">BuildDistanceMatrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.BuildDistanceMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.CalculateAtomization">
<code class="descname">CalculateAtomization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.CalculateAtomization" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Calculate_vdw">
<code class="descname">Calculate_vdw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Calculate_vdw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Center">
<code class="descname">Center</code><span class="sig-paren">(</span><em>CenterOf='Atom'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Center" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the center of atom or mass</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Distort">
<code class="descname">Distort</code><span class="sig-paren">(</span><em>disp=0.38</em>, <em>movechance=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Distort" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly distort my coords, but save eq. coords first</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.DistortAN">
<code class="descname">DistortAN</code><span class="sig-paren">(</span><em>movechance=0.15</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.DistortAN" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly replace atom types.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.EnergiesOfAtomMoves">
<code class="descname">EnergiesOfAtomMoves</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.EnergiesOfAtomMoves" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.EnergyAfterAtomMove">
<code class="descname">EnergyAfterAtomMove</code><span class="sig-paren">(</span><em>s</em>, <em>i</em>, <em>Type='GO'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.EnergyAfterAtomMove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Energy_from_xyz">
<code class="descname">Energy_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Energy_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the energy from the comment line in the md_dataset.
Switched on by has_energy=True in the ReadGDB9Unpacked routine</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.FitGoProb">
<code class="descname">FitGoProb</code><span class="sig-paren">(</span><em>ii</em>, <em>Print=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.FitGoProb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a Go-potential for atom i on a uniform grid of 4A with 50 pts/direction
And fits that go potential with the H&#64;0 basis centered at the same point
In practice 9 (1A) gaussians separated on a 1A grid around the sensory point appears to work for moderate distortions.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Force_from_xyz">
<code class="descname">Force_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Force_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the forces from the comment line in the md_dataset,
and if no forces exist sets them to zero. Switched on by
has_force=True in the ReadGDB9Unpacked routine</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.FromXYZString">
<code class="descname">FromXYZString</code><span class="sig-paren">(</span><em>string</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.FromXYZString" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Generate_All_MBE_term_General">
<code class="descname">Generate_All_MBE_term_General</code><span class="sig-paren">(</span><em>frag_list=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Generate_All_MBE_term_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Generate_MBE_term_General">
<code class="descname">Generate_MBE_term_General</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Generate_MBE_term_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.GoEnergy">
<code class="descname">GoEnergy</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.GoEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths. This is the lennard jones soft version</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.GoForce">
<code class="descname">GoForce</code><span class="sig-paren">(</span><em>at_=-1</em>, <em>spherical=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.GoForce" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths, and this is the force of that potential.
Args: <a href="#id33"><span class="problematic" id="id34">at_</span></a> an atom index, if <a href="#id35"><span class="problematic" id="id36">at_</span></a> = -1 it returns an array for each atom.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.GoForceLocal">
<code class="descname">GoForceLocal</code><span class="sig-paren">(</span><em>at_=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.GoForceLocal" title="Permalink to this definition">¶</a></dt>
<dd><p>The GO potential enforces equilibrium bond lengths, and this is the force of that potential.
A MUCH FASTER VERSION OF THIS ROUTINE IS NOW AVAILABLE, see MolEmb::Make_Go</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.GoForce_Scan">
<code class="descname">GoForce_Scan</code><span class="sig-paren">(</span><em>maxstep</em>, <em>ngrid</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.GoForce_Scan" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.GoHessian">
<code class="descname">GoHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.GoHessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.IsIsomer">
<code class="descname">IsIsomer</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.IsIsomer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.MBE_Dipole">
<code class="descname">MBE_Dipole</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.MBE_Dipole" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.MBE_Energy">
<code class="descname">MBE_Energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.MBE_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.MMFF94_Force_from_xyz">
<code class="descname">MMFF94_Force_from_xyz</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.MMFF94_Force_from_xyz" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the forces from the comment line in the md_dataset,
and if no forces exist sets them to zero. Switched on by
has_force=True in the ReadGDB9Unpacked routine
TODO: Move this out of Mol please to AbInitio (JAP)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Make_Spherical_Forces">
<code class="descname">Make_Spherical_Forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Make_Spherical_Forces" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.MolDots">
<code class="descname">MolDots</code><span class="sig-paren">(</span><em>ngrids=250</em>, <em>padding=2.0</em>, <em>width=2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.MolDots" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.MolGrids">
<code class="descname">MolGrids</code><span class="sig-paren">(</span><em>ngrids=250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.MolGrids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.MultipoleInputs">
<code class="descname">MultipoleInputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.MultipoleInputs" title="Permalink to this definition">¶</a></dt>
<dd><p>These are the quantities (in Atomic Units)
which you multiply the atomic charges by (and sum)
in order to calculate the multipoles of a molecule
up to PARAMS[&#8220;EEOrder&#8221;]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">(NAtoms X (monopole, dipole x, ... quad x... etc. ))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.NEles">
<code class="descname">NEles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.NEles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.NumOfAtomsE">
<code class="descname">NumOfAtomsE</code><span class="sig-paren">(</span><em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.NumOfAtomsE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Num_of_Heavy_Atom">
<code class="descname">Num_of_Heavy_Atom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Num_of_Heavy_Atom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.NumericGoHessian">
<code class="descname">NumericGoHessian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.NumericGoHessian" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.OverlapEmbeddings">
<code class="descname">OverlapEmbeddings</code><span class="sig-paren">(</span><em>d1</em>, <em>coords</em>, <em>d2</em>, <em>d3</em>, <em>d4</em>, <em>d5</em>, <em>i</em>, <em>d6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.OverlapEmbeddings" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.POfAtomMoves">
<code class="descname">POfAtomMoves</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.POfAtomMoves" title="Permalink to this definition">¶</a></dt>
<dd><p>Arguments are given relative to the coordinate of i</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.PySCFEnergyAfterAtomMove">
<code class="descname">PySCFEnergyAfterAtomMove</code><span class="sig-paren">(</span><em>s</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.PySCFEnergyAfterAtomMove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.PySCF_Energy">
<code class="descname">PySCF_Energy</code><span class="sig-paren">(</span><em>basis_='cc-pvqz'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.PySCF_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.ReadGDB9">
<code class="descname">ReadGDB9</code><span class="sig-paren">(</span><em>path</em>, <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.ReadGDB9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Reset_Frags">
<code class="descname">Reset_Frags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Reset_Frags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>axis</em>, <em>ang</em>, <em>origin=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atomic coordinates and forces if present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>axis</strong> &#8211; vector for rotation axis</li>
<li><strong>ang</strong> &#8211; radians of rotation</li>
<li><strong>origin</strong> &#8211; origin of rotation axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.RotateRandomUniform">
<code class="descname">RotateRandomUniform</code><span class="sig-paren">(</span><em>randnums=None</em>, <em>origin=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.RotateRandomUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate atomic coordinates and forces if present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>randnums</strong> &#8211; theta, phi, and z for rotation, if None then rotation is random</li>
<li><strong>origin</strong> &#8211; origin of rotation axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.RunPySCFWithCoords">
<code class="descname">RunPySCFWithCoords</code><span class="sig-paren">(</span><em>samps</em>, <em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.RunPySCFWithCoords" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.ScanNormalModes">
<code class="descname">ScanNormalModes</code><span class="sig-paren">(</span><em>npts=11</em>, <em>disp=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.ScanNormalModes" title="Permalink to this definition">¶</a></dt>
<dd><p>These modes are normal</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Set_EQ_force">
<code class="descname">Set_EQ_force</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Set_EQ_force" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets forces to 0 for equilibrium molecules with no force data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Set_Qchem_Data_Path">
<code class="descname">Set_Qchem_Data_Path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Set_Qchem_Data_Path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.SoftCutGoForce">
<code class="descname">SoftCutGoForce</code><span class="sig-paren">(</span><em>cutdist=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.SoftCutGoForce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.SoftCutGoForceOneAtom">
<code class="descname">SoftCutGoForceOneAtom</code><span class="sig-paren">(</span><em>at_</em>, <em>cutdist=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.SoftCutGoForceOneAtom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.SortAtoms">
<code class="descname">SortAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.SortAtoms" title="Permalink to this definition">¶</a></dt>
<dd><p>First sorts by element, then sorts by distance to the center of the molecule
This improves alignment.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.SpanningGrid">
<code class="descname">SpanningGrid</code><span class="sig-paren">(</span><em>num=250</em>, <em>pad=4.0</em>, <em>Flatten=True</em>, <em>Cubic=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.SpanningGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a regular grid the molecule fits into</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.Transform">
<code class="descname">Transform</code><span class="sig-paren">(</span><em>ltransf</em>, <em>center=array([ 0.</em>, <em>0.</em>, <em>0.])</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.Transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.UseGoProb">
<code class="descname">UseGoProb</code><span class="sig-paren">(</span><em>ii</em>, <em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.UseGoProb" title="Permalink to this definition">¶</a></dt>
<dd><p>The opposite of the routine above. It takes the digested probability vectors and uses it to calculate desired new positions.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.WriteInterpolation">
<code class="descname">WriteInterpolation</code><span class="sig-paren">(</span><em>b</em>, <em>n=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.WriteInterpolation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.WriteSmiles">
<code class="descname">WriteSmiles</code><span class="sig-paren">(</span><em>fpath='.'</em>, <em>fname='gdb9_smiles'</em>, <em>mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.WriteSmiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.WriteXYZfile">
<code class="descname">WriteXYZfile</code><span class="sig-paren">(</span><em>fpath='.'</em>, <em>fname='mol'</em>, <em>mode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.WriteXYZfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.XYZtoGridIndex">
<code class="descname">XYZtoGridIndex</code><span class="sig-paren">(</span><em>xyz</em>, <em>ngrids=250</em>, <em>padding=2.0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.XYZtoGridIndex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>atoms_=None</em>, <em>coords_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.FragableClusterBF.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.MolFrag'</em><a class="headerlink" href="#TensorMol.FragableClusterBF.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.rms" title="Permalink to this definition">¶</a></dt>
<dd><p>Cartesian coordinate difference.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableClusterBF.rms_inv">
<code class="descname">rms_inv</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableClusterBF.rms_inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Invariant coordinate difference.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.FragableMSet">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">FragableMSet</code><span class="sig-paren">(</span><em>name_='NaClH2O'</em>, <em>path_='./datasets/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.Sets.MSet</span></code></p>
<dl class="method">
<dt id="TensorMol.FragableMSet.AppendFromDirectory">
<code class="descname">AppendFromDirectory</code><span class="sig-paren">(</span><em>apath_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.AppendFromDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Append all xyz files in <a href="#id37"><span class="problematic" id="id38">apath_</span></a> to this set.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.AppendSet">
<code class="descname">AppendSet</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.AppendSet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Calculate_All_Frag_Energy">
<code class="descname">Calculate_All_Frag_Energy</code><span class="sig-paren">(</span><em>method='pyscf'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Calculate_All_Frag_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Calculate_All_Frag_Energy_General">
<code class="descname">Calculate_All_Frag_Energy_General</code><span class="sig-paren">(</span><em>method='pyscf'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Calculate_All_Frag_Energy_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Calculate_vdw">
<code class="descname">Calculate_vdw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Calculate_vdw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.CenterSet">
<code class="descname">CenterSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.CenterSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates every Mol such that the center is at 0.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Clean_GDB9">
<code class="descname">Clean_GDB9</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Clean_GDB9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.DistortAlongNormals">
<code class="descname">DistortAlongNormals</code><span class="sig-paren">(</span><em>npts=8</em>, <em>random=True</em>, <em>disp=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.DistortAlongNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distorted copy of a set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>npts</strong> &#8211; the number of points to sample along the normal mode coordinate.</li>
<li><strong>random</strong> &#8211; whether to randomize the order of the new set.</li>
<li><strong>disp</strong> &#8211; the maximum displacement of atoms along the mode</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A set containing distorted versions of the original set.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.DistortedClone">
<code class="descname">DistortedClone</code><span class="sig-paren">(</span><em>NDistorts=1</em>, <em>random=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.DistortedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distorted copy of a set</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.EQ_forces">
<code class="descname">EQ_forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.EQ_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets forces to 0 for every molecule which has no forces</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Generate_All_MBE_term">
<code class="descname">Generate_All_MBE_term</code><span class="sig-paren">(</span><em>atom_group=1</em>, <em>cutoff=10</em>, <em>center_atom=0</em>, <em>max_case=1000000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Generate_All_MBE_term" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Generate_All_MBE_term_General">
<code class="descname">Generate_All_MBE_term_General</code><span class="sig-paren">(</span><em>frag_list=[]</em>, <em>cutoff=10</em>, <em>center_atom=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Generate_All_MBE_term_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Generate_All_Pairs">
<code class="descname">Generate_All_Pairs</code><span class="sig-paren">(</span><em>pair_list=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Generate_All_Pairs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Get_All_Qchem_Frag_Energy">
<code class="descname">Get_All_Qchem_Frag_Energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Get_All_Qchem_Frag_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Get_All_Qchem_Frag_Energy_General">
<code class="descname">Get_All_Qchem_Frag_Energy_General</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Get_All_Qchem_Frag_Energy_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Get_Permute_Frags">
<code class="descname">Get_Permute_Frags</code><span class="sig-paren">(</span><em>indis=[0]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Get_Permute_Frags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.MBE">
<code class="descname">MBE</code><span class="sig-paren">(</span><em>atom_group=1</em>, <em>cutoff=10</em>, <em>center_atom=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.MBE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Make_Graphs">
<code class="descname">Make_Graphs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Make_Graphs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.MaxNAtoms">
<code class="descname">MaxNAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.MaxNAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.OnlyWithElements">
<code class="descname">OnlyWithElements</code><span class="sig-paren">(</span><em>allowed_eles</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.OnlyWithElements" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.PySCF_Energy">
<code class="descname">PySCF_Energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.PySCF_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.ReadGDB9Unpacked">
<code class="descname">ReadGDB9Unpacked</code><span class="sig-paren">(</span><em>path='/Users/johnparkhill/gdb9/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.ReadGDB9Unpacked" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the GDB9 dataset as a pickled list of molecules</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.ReadXYZ">
<code class="descname">ReadXYZ</code><span class="sig-paren">(</span><em>filename</em>, <em>xyz_type='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.ReadXYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads XYZs concatenated into a single separated by</p>
<p>file as a molset</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.ReadXYZUnpacked">
<code class="descname">ReadXYZUnpacked</code><span class="sig-paren">(</span><em>path='/Users/johnparkhill/gdb9/'</em>, <em>has_energy=False</em>, <em>has_force=False</em>, <em>has_mmff94=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.ReadXYZUnpacked" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads XYZs in distinct files in one directory as a molset
:param path: the directory which contains the .xyz files to be read
:param has_energy: switch to turn on reading the energy from the comment line as formatted from the md_dataset on quantum-machine.org
:param has_force: switch to turn on reading the force from the comment line as formatted from the md_dataset on quantum-machine.org</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.RotatedClone">
<code class="descname">RotatedClone</code><span class="sig-paren">(</span><em>NRots=3</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.RotatedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate every molecule NRots Times.
We should toss some reflections in the mix too...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Set_Qchem_Data_Path">
<code class="descname">Set_Qchem_Data_Path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Set_Qchem_Data_Path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.Statistics">
<code class="descname">Statistics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.Statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return some energy information about the samples we have...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.TransformedClone">
<code class="descname">TransformedClone</code><span class="sig-paren">(</span><em>transfs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.TransformedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>make a linearly transformed copy of a set.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.WriteSmiles">
<code class="descname">WriteSmiles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.WriteSmiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.WriteXYZ">
<code class="descname">WriteXYZ</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.WriteXYZ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>name_='NaClH2O'</em>, <em>path_='./datasets/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.FragableMSet.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Sets'</em><a class="headerlink" href="#TensorMol.FragableMSet.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>ntopop</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.pop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSet.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>other_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSet.rms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.FragableMSetBF">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">FragableMSetBF</code><span class="sig-paren">(</span><em>name_='NaClH2O'</em>, <em>path_='./datasets/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.Sets.FragableMSet</span></code></p>
<dl class="method">
<dt id="TensorMol.FragableMSetBF.AppendFromDirectory">
<code class="descname">AppendFromDirectory</code><span class="sig-paren">(</span><em>apath_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.AppendFromDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Append all xyz files in <a href="#id39"><span class="problematic" id="id40">apath_</span></a> to this set.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.AppendSet">
<code class="descname">AppendSet</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.AppendSet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Calculate_All_Frag_Energy">
<code class="descname">Calculate_All_Frag_Energy</code><span class="sig-paren">(</span><em>method='pyscf'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Calculate_All_Frag_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Calculate_All_Frag_Energy_General">
<code class="descname">Calculate_All_Frag_Energy_General</code><span class="sig-paren">(</span><em>method='pyscf'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Calculate_All_Frag_Energy_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Calculate_vdw">
<code class="descname">Calculate_vdw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Calculate_vdw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.CenterSet">
<code class="descname">CenterSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.CenterSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates every Mol such that the center is at 0.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Clean_GDB9">
<code class="descname">Clean_GDB9</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Clean_GDB9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.DistortAlongNormals">
<code class="descname">DistortAlongNormals</code><span class="sig-paren">(</span><em>npts=8</em>, <em>random=True</em>, <em>disp=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.DistortAlongNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distorted copy of a set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>npts</strong> &#8211; the number of points to sample along the normal mode coordinate.</li>
<li><strong>random</strong> &#8211; whether to randomize the order of the new set.</li>
<li><strong>disp</strong> &#8211; the maximum displacement of atoms along the mode</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A set containing distorted versions of the original set.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.DistortedClone">
<code class="descname">DistortedClone</code><span class="sig-paren">(</span><em>NDistorts=1</em>, <em>random=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.DistortedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distorted copy of a set</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.EQ_forces">
<code class="descname">EQ_forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.EQ_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets forces to 0 for every molecule which has no forces</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Generate_All_MBE_term">
<code class="descname">Generate_All_MBE_term</code><span class="sig-paren">(</span><em>atom_group=1</em>, <em>cutoff=10</em>, <em>center_atom=0</em>, <em>max_case=1000000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Generate_All_MBE_term" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Generate_All_MBE_term_General">
<code class="descname">Generate_All_MBE_term_General</code><span class="sig-paren">(</span><em>frag_list=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Generate_All_MBE_term_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Generate_All_Pairs">
<code class="descname">Generate_All_Pairs</code><span class="sig-paren">(</span><em>pair_list=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Generate_All_Pairs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Get_All_Qchem_Frag_Energy">
<code class="descname">Get_All_Qchem_Frag_Energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Get_All_Qchem_Frag_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Get_All_Qchem_Frag_Energy_General">
<code class="descname">Get_All_Qchem_Frag_Energy_General</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Get_All_Qchem_Frag_Energy_General" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Get_Permute_Frags">
<code class="descname">Get_Permute_Frags</code><span class="sig-paren">(</span><em>indis=[0]</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Get_Permute_Frags" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.MBE">
<code class="descname">MBE</code><span class="sig-paren">(</span><em>atom_group=1</em>, <em>cutoff=10</em>, <em>center_atom=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.MBE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Make_Graphs">
<code class="descname">Make_Graphs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Make_Graphs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.MaxNAtoms">
<code class="descname">MaxNAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.MaxNAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.OnlyWithElements">
<code class="descname">OnlyWithElements</code><span class="sig-paren">(</span><em>allowed_eles</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.OnlyWithElements" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.PySCF_Energy">
<code class="descname">PySCF_Energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.PySCF_Energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.ReadGDB9Unpacked">
<code class="descname">ReadGDB9Unpacked</code><span class="sig-paren">(</span><em>path='/Users/johnparkhill/gdb9/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.ReadGDB9Unpacked" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the GDB9 dataset as a pickled list of molecules</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.ReadXYZ">
<code class="descname">ReadXYZ</code><span class="sig-paren">(</span><em>filename</em>, <em>xyz_type='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.ReadXYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads XYZs concatenated into a single separated by</p>
<p>file as a molset</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.ReadXYZUnpacked">
<code class="descname">ReadXYZUnpacked</code><span class="sig-paren">(</span><em>path='/Users/johnparkhill/gdb9/'</em>, <em>has_energy=False</em>, <em>has_force=False</em>, <em>has_mmff94=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.ReadXYZUnpacked" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads XYZs in distinct files in one directory as a molset
:param path: the directory which contains the .xyz files to be read
:param has_energy: switch to turn on reading the energy from the comment line as formatted from the md_dataset on quantum-machine.org
:param has_force: switch to turn on reading the force from the comment line as formatted from the md_dataset on quantum-machine.org</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.RotatedClone">
<code class="descname">RotatedClone</code><span class="sig-paren">(</span><em>NRots=3</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.RotatedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate every molecule NRots Times.
We should toss some reflections in the mix too...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Set_Qchem_Data_Path">
<code class="descname">Set_Qchem_Data_Path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Set_Qchem_Data_Path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.Statistics">
<code class="descname">Statistics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.Statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return some energy information about the samples we have...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.TransformedClone">
<code class="descname">TransformedClone</code><span class="sig-paren">(</span><em>transfs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.TransformedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>make a linearly transformed copy of a set.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.WriteSmiles">
<code class="descname">WriteSmiles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.WriteSmiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.WriteXYZ">
<code class="descname">WriteXYZ</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.WriteXYZ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>name_='NaClH2O'</em>, <em>path_='./datasets/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.FragableMSetBF.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Sets'</em><a class="headerlink" href="#TensorMol.FragableMSetBF.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>ntopop</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.pop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.FragableMSetBF.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>other_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.FragableMSetBF.rms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.GraphSet">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">GraphSet</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>path_='./datasets/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.GraphSet" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.GraphSet.BondTypes">
<code class="descname">BondTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.GraphSet.BondTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.GraphSet.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.GraphSet.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.GraphSet.NBonds">
<code class="descname">NBonds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.GraphSet.NBonds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.GraphSet.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.GraphSet.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.GraphSet.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>path_='./datasets/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.GraphSet.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.GraphSet.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Sets'</em><a class="headerlink" href="#TensorMol.GraphSet.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.GridstoRaw">
<code class="descclassname">TensorMol.</code><code class="descname">GridstoRaw</code><span class="sig-paren">(</span><em>grids</em>, <em>ngrids=250</em>, <em>save_name='mol'</em>, <em>save_path='./densities/'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.GridstoRaw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.HarmonicSpectra">
<code class="descclassname">TensorMol.</code><code class="descname">HarmonicSpectra</code><span class="sig-paren">(</span><em>f_</em>, <em>x_</em>, <em>m_</em>, <em>grad_=None</em>, <em>eps_=0.04</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.HarmonicSpectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a finite difference normal mode analysis
of a molecule. basically implements <a class="reference external" href="http://gaussian.com/vib/">http://gaussian.com/vib/</a>
<a href="#id41"><span class="problematic" id="id42">f_</span></a>: Energies in Hartree.
<a href="#id43"><span class="problematic" id="id44">x_</span></a>: Coordinates (A)
<a href="#id45"><span class="problematic" id="id46">m_</span></a>: masses (kg/mol)
<a href="#id47"><span class="problematic" id="id48">grad_</span></a>: forces in Hartree/angstrom if available.</p>
</dd></dl>

<dl class="class">
<dt id="TensorMol.IRTrajectory">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">IRTrajectory</code><span class="sig-paren">(</span><em>f_</em>, <em>q_</em>, <em>g0_</em>, <em>name_='0'</em>, <em>v0_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.IRTrajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.SimpleMD.VelocityVerlet</span></code></p>
<dl class="method">
<dt id="TensorMol.IRTrajectory.ForcesWithCharge">
<code class="descname">ForcesWithCharge</code><span class="sig-paren">(</span><em>x_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.IRTrajectory.ForcesWithCharge" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.IRTrajectory.Prop">
<code class="descname">Prop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.IRTrajectory.Prop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.IRTrajectory.Pulse">
<code class="descname">Pulse</code><span class="sig-paren">(</span><em>t_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.IRTrajectory.Pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>delta pulse of duration</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.IRTrajectory.WriteTrajectory">
<code class="descname">WriteTrajectory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.IRTrajectory.WriteTrajectory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.IRTrajectory.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>f_</em>, <em>q_</em>, <em>g0_</em>, <em>name_='0'</em>, <em>v0_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.IRTrajectory.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A specialized sort of dynamics which is appropriate for obtaining IR spectra at
Zero temperature. Absorption cross section is given by:
alpha = frac{4pi^2}{hbar c} omega (1 - Exp[-beta hbar omega]) sigma(omega))
sigma  = frac{1}{6 pi} mathcal{F} {mu(t)mu(0)}</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> &#8211; a function which yields the force</li>
<li><strong>q</strong> &#8211; a function which yields the charge.</li>
<li><strong>g0</strong> &#8211; an initial geometry.</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDFieldVec&quot;</strong><strong>]</strong><strong></strong> &#8211; </li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDFieldAmp&quot;</strong><strong>]</strong><strong></strong> &#8211; </li>
<li><strong>= 3.0</strong> (<em>PARAMS</em><em>[</em><em>&quot;MDFieldT0&quot;</em><em>]</em><em></em>) &#8211; </li>
<li><strong>= 1.2 #1.2 fs pulse.</strong> (<em>PARAMS</em><em>[</em><em>&quot;MDFieldTau&quot;</em><em>]</em><em></em>) &#8211; </li>
<li><strong>= 1/1.2 # 700nm light is about 1/1.2 fs.</strong> (<em>PARAMS</em><em>[</em><em>&quot;MDFieldFreq&quot;</em><em>]</em><em></em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.IRTrajectory.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.SimpleMD'</em><a class="headerlink" href="#TensorMol.IRTrajectory.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.InertiaTensor">
<code class="descclassname">TensorMol.</code><code class="descname">InertiaTensor</code><span class="sig-paren">(</span><em>x_</em>, <em>m_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.InertiaTensor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="TensorMol.Instance">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Instance</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages a persistent training network instance</p>
<dl class="method">
<dt id="TensorMol.Instance.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=1250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.Prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Called if only evaluations are being done, by evaluate()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>TData</strong> &#8211; a TensorData</li>
<li><strong>ele</strong> &#8211; an element type for this instance.</li>
<li><strong>Name</strong> &#8211; a name for this instance, attempts to load from checkpoint.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.Instance.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFInstance'</em><a class="headerlink" href="#TensorMol.Instance.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>images</em>, <em>bleep</em>, <em>bloop</em>, <em>blop</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the MNIST model up to where it may be used for inference.
Args:
images: Images placeholder, from inputs().
hidden1_units: Size of the first hidden layer.
hidden2_units: Size of the second hidden layer.
Returns:
softmax_linear: Output tensor with the computed logits.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the loss from the logits and the labels.
Args:
logits: Logits tensor, float - [batch_size, NUM_CLASSES].
labels: Labels tensor, int32 - [batch_size].
Returns:
loss: Loss tensor of type float.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Instance_3dconv_sqdiff">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Instance_3dconv_sqdiff</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFInstance.Instance</span></code></p>
<p>Let&#8217;s see if a 3d-convolutional network improves the learning rate on the Gaussian grids.</p>
<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=1250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.Prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Called if only evaluations are being done, by evaluate()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Instance_3dconv_sqdiff.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFInstance'</em><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff._bias_variable">
<code class="descname">_bias_variable</code><span class="sig-paren">(</span><em>name</em>, <em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff._bias_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff._weight_variable">
<code class="descname">_weight_variable</code><span class="sig-paren">(</span><em>name</em>, <em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff._weight_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.inference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.loss_op" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.
These placeholders are used as inputs by the rest of the model building
code and will be fed from the downloaded data in the .run() loop, below.
Args:
batch_size: The batch size will be baked into both placeholders.
Returns:
embeds_placeholder: Images placeholder.
labels_placeholder: Labels placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_3dconv_sqdiff.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_3dconv_sqdiff.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Instance_KRR">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Instance_KRR</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFInstance.Instance</span></code></p>
<dl class="method">
<dt id="TensorMol.Instance_KRR.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=1250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.Prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Called if only evaluations are being done, by evaluate()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Instance_KRR.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFInstance'</em><a class="headerlink" href="#TensorMol.Instance_KRR.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.basis_opt_run">
<code class="descname">basis_opt_run</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.basis_opt_run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>images</em>, <em>bleep</em>, <em>bloop</em>, <em>blop</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the MNIST model up to where it may be used for inference.
Args:
images: Images placeholder, from inputs().
hidden1_units: Size of the first hidden layer.
hidden2_units: Size of the second hidden layer.
Returns:
softmax_linear: Output tensor with the computed logits.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the loss from the logits and the labels.
Args:
logits: Logits tensor, float - [batch_size, NUM_CLASSES].
labels: Labels tensor, int32 - [batch_size].
Returns:
loss: Loss tensor of type float.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>n_step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_KRR.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_KRR.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Instance_conv2d_sqdiff">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Instance_conv2d_sqdiff</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFInstance.Instance</span></code></p>
<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=1250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.Prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Called if only evaluations are being done, by evaluate()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Instance_conv2d_sqdiff.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFInstance'</em><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff._bias_variable">
<code class="descname">_bias_variable</code><span class="sig-paren">(</span><em>name</em>, <em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff._bias_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff._weight_variable">
<code class="descname">_weight_variable</code><span class="sig-paren">(</span><em>name</em>, <em>shape</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff._weight_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.conv2d">
<code class="descname">conv2d</code><span class="sig-paren">(</span><em>x</em>, <em>W</em>, <em>b</em>, <em>strides=1</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.conv2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D Convolution wrapper with bias and relu activation</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.inference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.loss_op" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.
These placeholders are used as inputs by the rest of the model building
code and will be fed from the downloaded data in the .run() loop, below.
Args:
batch_size: The batch size will be baked into both placeholders.
Returns:
embeds_placeholder: Images placeholder.
labels_placeholder: Labels placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_conv2d_sqdiff.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_conv2d_sqdiff.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Instance_del_fc_sqdiff">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Instance_del_fc_sqdiff</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFInstance.Instance_fc_sqdiff</span></code></p>
<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=1250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.Prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Called if only evaluations are being done, by evaluate()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Instance_del_fc_sqdiff.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFInstance'</em><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>images</em>, <em>bleep</em>, <em>bloop</em>, <em>blop</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the MNIST model up to where it may be used for inference.
Args:
images: Images placeholder, from inputs().
hidden1_units: Size of the first hidden layer.
hidden2_units: Size of the second hidden layer.
Returns:
softmax_linear: Output tensor with the computed logits.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.loss_op" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.
These placeholders are used as inputs by the rest of the model building
code and will be fed from the downloaded data in the .run() loop, below.
Args:
batch_size: The batch size will be baked into both placeholders.
Returns:
embeds_placeholder: Images placeholder.
labels_placeholder: Labels placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_del_fc_sqdiff.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_del_fc_sqdiff.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Instance_fc_classify">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Instance_fc_classify</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFInstance.Instance</span></code></p>
<dl class="method">
<dt id="TensorMol.Instance_fc_classify.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=1250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Instance_fc_classify.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFInstance'</em><a class="headerlink" href="#TensorMol.Instance_fc_classify.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>images</em>, <em>bleep</em>, <em>bloop</em>, <em>blop</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the MNIST model up to where it may be used for inference.
Args:
images: Images placeholder, from inputs().
hidden1_units: Size of the first hidden layer.
hidden2_units: Size of the second hidden layer.
Returns:
softmax_linear: Output tensor with the computed logits.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.justpreds">
<code class="descname">justpreds</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.justpreds" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the loss from the logits and the labels.
Args:
logits: Logits tensor, float - [batch_size, NUM_CLASSES].
labels: Labels tensor, int32 - [batch_size].
Returns:
loss: Loss tensor of type float.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the loss from the logits and the labels.
Args:
logits: Logits tensor, float - [batch_size, NUM_CLASSES].
labels: Labels tensor, int32 - [batch_size].
Returns:
loss: Loss tensor of type float.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.n_correct">
<code class="descname">n_correct</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.n_correct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.
These placeholders are used as inputs by the rest of the model building
code and will be fed from the downloaded data in the .run() loop, below.
Args:
batch_size: The batch size will be baked into both placeholders.
Returns:
embeds_placeholder: Images placeholder.
labels_placeholder: Labels placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>total_correct</em>, <em>Ncase</em>, <em>duration</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_classify.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_classify.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Instance_fc_sqdiff">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Instance_fc_sqdiff</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFInstance.Instance</span></code></p>
<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=1250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.Prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Called if only evaluations are being done, by evaluate()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>ele_=1</em>, <em>Name_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.Instance_fc_sqdiff.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFInstance'</em><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>images</em>, <em>bleep</em>, <em>bloop</em>, <em>blop</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the MNIST model up to where it may be used for inference.
Args:
images: Images placeholder, from inputs().
hidden1_units: Size of the first hidden layer.
hidden2_units: Size of the second hidden layer.
Returns:
softmax_linear: Output tensor with the computed logits.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.loss_op" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.
These placeholders are used as inputs by the rest of the model building
code and will be fed from the downloaded data in the .run() loop, below.
Args:
batch_size: The batch size will be baked into both placeholders.
Returns:
embeds_placeholder: Images placeholder.
labels_placeholder: Labels placeholder.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Instance_fc_sqdiff.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Instance_fc_sqdiff.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.InternalCoordinates">
<code class="descclassname">TensorMol.</code><code class="descname">InternalCoordinates</code><span class="sig-paren">(</span><em>x_</em>, <em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.InternalCoordinates" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a set of internal (ie: rot-trans free)
vectors spanning coordinates for asymmetric mols.
If you are doing a diatomic, use a quantum chemistry package</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.KineticEnergy">
<code class="descclassname">TensorMol.</code><code class="descname">KineticEnergy</code><span class="sig-paren">(</span><em>v_</em>, <em>m_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.KineticEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>The KineticEnergy</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>masses are in kg.</strong> (<em>The</em>) &#8211; </li>
<li><strong>v</strong> &#8211; Velocities (A/fs)</li>
<li><strong>m</strong> &#8211; the mass vector. (kg/mol)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The kinetic energy per atom (kJ/mol)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.LJEnergies">
<code class="descclassname">TensorMol.</code><code class="descname">LJEnergies</code><span class="sig-paren">(</span><em>XYZs_</em>, <em>Zs_</em>, <em>Ee_</em>, <em>Re_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.LJEnergies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns LJ Energies batched over molecules.
:param <a href="#id49"><span class="problematic" id="id50">XYZs_</span></a>: nmols X maxatom X 3 coordinate tensor.
:param <a href="#id51"><span class="problematic" id="id52">Zs_</span></a>: nmols X maxatom X 1 atomic number tensor.
:param <a href="#id53"><span class="problematic" id="id54">Ee_</span></a>: MAX_ATOMIC_NUMBER X MAX_ATOMIC_NUMBER Epsilon parameter matrix.
:param <a href="#id55"><span class="problematic" id="id56">Ee_</span></a>: MAX_ATOMIC_NUMBER X MAX_ATOMIC_NUMBER Re parameter matrix.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.LJForce">
<code class="descclassname">TensorMol.</code><code class="descname">LJForce</code><span class="sig-paren">(</span><em>xyz_</em>, <em>Z_</em>, <em>inds_</em>, <em>Ee_</em>, <em>Re_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.LJForce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.LJKernel">
<code class="descclassname">TensorMol.</code><code class="descname">LJKernel</code><span class="sig-paren">(</span><em>D</em>, <em>Z</em>, <em>Ee</em>, <em>Re</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.LJKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>A Lennard-Jones Kernel
:param D: A square distance matrix (bohr)
:param Z: Atomic Numbers.
:param Ee: a matrix of LJ well depths.
:param Re: a matrix of Bond minima.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.LJKernels">
<code class="descclassname">TensorMol.</code><code class="descname">LJKernels</code><span class="sig-paren">(</span><em>Ds</em>, <em>Zs</em>, <em>Ee</em>, <em>Re</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.LJKernels" title="Permalink to this definition">¶</a></dt>
<dd><p>Batched over molecules.
:param Ds: A batch of square distance matrix (bohr)
:param Zs: A batch of Atomic Numbers.
:param Ee: a matrix of LJ well depths.
:param Re: a matrix of Bond minima.</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>A #Mols X MaxNAtoms X MaxNAtoms matrix of LJ kernel contributions.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="TensorMol.LearnLJ">
<code class="descclassname">TensorMol.</code><code class="descname">LearnLJ</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.LearnLJ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.LineSearch">
<code class="descclassname">TensorMol.</code><code class="descname">LineSearch</code><span class="sig-paren">(</span><em>f_</em>, <em>x0_</em>, <em>p_</em>, <em>thresh=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.LineSearch" title="Permalink to this definition">¶</a></dt>
<dd><p>golden section search to find the minimum of f on [a,b]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> &#8211; a function which returns energy.</li>
<li><strong>x0</strong> &#8211; Origin of the search.</li>
<li><strong>p</strong> &#8211; search direction.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.LineSearchCart">
<code class="descclassname">TensorMol.</code><code class="descname">LineSearchCart</code><span class="sig-paren">(</span><em>f_</em>, <em>x0_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.LineSearchCart" title="Permalink to this definition">¶</a></dt>
<dd><p>A line search in each cartesian direction.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.LtoS">
<code class="descclassname">TensorMol.</code><code class="descname">LtoS</code><span class="sig-paren">(</span><em>l</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.LtoS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="TensorMol.MSet">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MSet</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>path_='./datasets/'</em>, <em>center_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet" title="Permalink to this definition">¶</a></dt>
<dd><p>A molecular database which
provides structures</p>
<dl class="method">
<dt id="TensorMol.MSet.AppendFromDirectory">
<code class="descname">AppendFromDirectory</code><span class="sig-paren">(</span><em>apath_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.AppendFromDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Append all xyz files in <a href="#id57"><span class="problematic" id="id58">apath_</span></a> to this set.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.AppendSet">
<code class="descname">AppendSet</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.AppendSet" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.Calculate_vdw">
<code class="descname">Calculate_vdw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.Calculate_vdw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.CenterSet">
<code class="descname">CenterSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.CenterSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates every Mol such that the center is at 0.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.Clean_GDB9">
<code class="descname">Clean_GDB9</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.Clean_GDB9" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.DistortAlongNormals">
<code class="descname">DistortAlongNormals</code><span class="sig-paren">(</span><em>npts=8</em>, <em>random=True</em>, <em>disp=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.DistortAlongNormals" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distorted copy of a set</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>npts</strong> &#8211; the number of points to sample along the normal mode coordinate.</li>
<li><strong>random</strong> &#8211; whether to randomize the order of the new set.</li>
<li><strong>disp</strong> &#8211; the maximum displacement of atoms along the mode</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A set containing distorted versions of the original set.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.DistortedClone">
<code class="descname">DistortedClone</code><span class="sig-paren">(</span><em>NDistorts=1</em>, <em>random=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.DistortedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a distorted copy of a set</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.EQ_forces">
<code class="descname">EQ_forces</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.EQ_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets forces to 0 for every molecule which has no forces</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.Make_Graphs">
<code class="descname">Make_Graphs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.Make_Graphs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.MaxNAtoms">
<code class="descname">MaxNAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.MaxNAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.OnlyWithElements">
<code class="descname">OnlyWithElements</code><span class="sig-paren">(</span><em>allowed_eles</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.OnlyWithElements" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.ReadXYZ">
<code class="descname">ReadXYZ</code><span class="sig-paren">(</span><em>filename=None</em>, <em>xyz_type='mol'</em>, <em>eqforce=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.ReadXYZ" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads XYZs concatenated into a single file separated by</p>
<p>as a molset</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.ReadXYZUnpacked">
<code class="descname">ReadXYZUnpacked</code><span class="sig-paren">(</span><em>path='/Users/johnparkhill/gdb9/'</em>, <em>has_energy=False</em>, <em>has_force=False</em>, <em>has_mmff94=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.ReadXYZUnpacked" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads XYZs in distinct files in one directory as a molset
:param path: the directory which contains the .xyz files to be read
:param has_energy: switch to turn on reading the energy from the comment line as formatted from the md_dataset on quantum-machine.org
:param has_force: switch to turn on reading the force from the comment line as formatted from the md_dataset on quantum-machine.org</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.RotatedClone">
<code class="descname">RotatedClone</code><span class="sig-paren">(</span><em>NRots=3</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.RotatedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>Rotate every molecule NRots Times.
We should toss some reflections in the mix too...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.Statistics">
<code class="descname">Statistics</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.Statistics" title="Permalink to this definition">¶</a></dt>
<dd><p>Return some energy information about the samples we have...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.TransformedClone">
<code class="descname">TransformedClone</code><span class="sig-paren">(</span><em>transfs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.TransformedClone" title="Permalink to this definition">¶</a></dt>
<dd><p>make a linearly transformed copy of a set.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.WriteSmiles">
<code class="descname">WriteSmiles</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.WriteSmiles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.WriteXYZ">
<code class="descname">WriteXYZ</code><span class="sig-paren">(</span><em>filename=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.WriteXYZ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>path_='./datasets/'</em>, <em>center_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.MSet.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Sets'</em><a class="headerlink" href="#TensorMol.MSet.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>ntopop</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.pop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MSet.rms">
<code class="descname">rms</code><span class="sig-paren">(</span><em>other_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MSet.rms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.MakeUniform">
<code class="descclassname">TensorMol.</code><code class="descname">MakeUniform</code><span class="sig-paren">(</span><em>point</em>, <em>disp</em>, <em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MakeUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Uniform Grids of dim numxnumxnum around a point</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.MatrixPower">
<code class="descclassname">TensorMol.</code><code class="descname">MatrixPower</code><span class="sig-paren">(</span><em>A</em>, <em>p</em>, <em>PrintCondition=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MatrixPower" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise a Hermitian Matrix to a possibly fractional power.</p>
</dd></dl>

<dl class="class">
<dt id="TensorMol.MolDigester">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolDigester</code><span class="sig-paren">(</span><em>eles_</em>, <em>name_='Coulomb'</em>, <em>OType_='FragEnergy'</em>, <em>SensRadius_=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.MolDigester.Emb">
<code class="descname">Emb</code><span class="sig-paren">(</span><em>mol_</em>, <em>MakeOutputs=True</em>, <em>MakeGradients=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.Emb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates various molecular embeddings.
If the embedding has BP on the end it comes out atomwise and includes all atoms in the molecule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol</strong> &#8211; a Molecule to be digested</li>
<li><strong>MakeOutputs</strong> &#8211; generates outputs according to self.OType.</li>
<li><strong>MakeGradients</strong> &#8211; generates outputs according to self.OType.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Output embeddings, and possibly labels and gradients.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">Hook up the gradients.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.EvalDigest">
<code class="descname">EvalDigest</code><span class="sig-paren">(</span><em>mol_</em>, <em>gradient_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.EvalDigest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.GetUpTri">
<code class="descname">GetUpTri</code><span class="sig-paren">(</span><em>CM</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.GetUpTri" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.Print">
<code class="descname">Print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.Print" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.TrainDigest">
<code class="descname">TrainDigest</code><span class="sig-paren">(</span><em>mol_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.TrainDigest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of inputs and outputs for a molecule.
Uses self.Emb() uses Mol to get the Desired output type (Energy,Force,Probability etc.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mol</strong> &#8211; a molecule to be digested</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>eles_</em>, <em>name_='Coulomb'</em>, <em>OType_='FragEnergy'</em>, <em>SensRadius_=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolDigester.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.DigestMol'</em><a class="headerlink" href="#TensorMol.MolDigester.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_ANI1_sym">
<code class="descname">make_ANI1_sym</code><span class="sig-paren">(</span><em>mol</em>, <em>MakeGradients_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_ANI1_sym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_ANI1_sym_bond_bp">
<code class="descname">make_ANI1_sym_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_ANI1_sym_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_ANI1_sym_center_bond_bp">
<code class="descname">make_ANI1_sym_center_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_ANI1_sym_center_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_cm">
<code class="descname">make_cm</code><span class="sig-paren">(</span><em>mol_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_cm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_cm_bond_bp">
<code class="descname">make_cm_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_cm_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_cm_bp">
<code class="descname">make_cm_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_cm_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_connectedbond_angle_bond_bp">
<code class="descname">make_connectedbond_angle_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_connectedbond_angle_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_connectedbond_bond_bp">
<code class="descname">make_connectedbond_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_connectedbond_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_gauinv">
<code class="descname">make_gauinv</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_gauinv" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a totally inefficient way of doing this
MolEmb should loop atoms.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_sym">
<code class="descname">make_sym</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_sym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigester.make_sym_update">
<code class="descname">make_sym_update</code><span class="sig-paren">(</span><em>mol</em>, <em>Rc=4.0</em>, <em>g1_para_mat=None</em>, <em>g2_para_mat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigester.make_sym_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolDigesterEE">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolDigesterEE</code><span class="sig-paren">(</span><em>eles_</em>, <em>name_='ANI1_Sym'</em>, <em>OType_='EnergyChargesDipole'</em>, <em>SensRadius_=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.DigestMol.MolDigester</span></code></p>
<dl class="method">
<dt id="TensorMol.MolDigesterEE.Emb">
<code class="descname">Emb</code><span class="sig-paren">(</span><em>mol_</em>, <em>MakeOutputs=True</em>, <em>MakeGradients=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.Emb" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates various molecular embeddings.
If the embedding has BP on the end it comes out atomwise and includes all atoms in the molecule.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol</strong> &#8211; a Molecule to be digested</li>
<li><strong>MakeOutputs</strong> &#8211; generates outputs according to self.OType.</li>
<li><strong>MakeGradients</strong> &#8211; generates outputs according to self.OType.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Output embeddings, and possibly labels and gradients.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Hook up the gradients.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.EvalDigest">
<code class="descname">EvalDigest</code><span class="sig-paren">(</span><em>mol_</em>, <em>gradient_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.EvalDigest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.GetUpTri">
<code class="descname">GetUpTri</code><span class="sig-paren">(</span><em>CM</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.GetUpTri" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.Print">
<code class="descname">Print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.Print" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.TrainDigest">
<code class="descname">TrainDigest</code><span class="sig-paren">(</span><em>mol_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.TrainDigest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns list of inputs and outputs for a molecule.
Uses self.Emb() uses Mol to get the Desired output type (Energy,Force,Probability etc.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mol</strong> &#8211; a molecule to be digested</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>eles_</em>, <em>name_='ANI1_Sym'</em>, <em>OType_='EnergyChargesDipole'</em>, <em>SensRadius_=6</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>A digester for electrostatically embedded BP.</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolDigesterEE.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.DigestMol'</em><a class="headerlink" href="#TensorMol.MolDigesterEE.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_ANI1_sym">
<code class="descname">make_ANI1_sym</code><span class="sig-paren">(</span><em>mol</em>, <em>MakeGradients_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_ANI1_sym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_ANI1_sym_bond_bp">
<code class="descname">make_ANI1_sym_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_ANI1_sym_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_ANI1_sym_center_bond_bp">
<code class="descname">make_ANI1_sym_center_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_ANI1_sym_center_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_cm">
<code class="descname">make_cm</code><span class="sig-paren">(</span><em>mol_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_cm" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_cm_bond_bp">
<code class="descname">make_cm_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_cm_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_cm_bp">
<code class="descname">make_cm_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_cm_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_connectedbond_angle_bond_bp">
<code class="descname">make_connectedbond_angle_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_connectedbond_angle_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_connectedbond_bond_bp">
<code class="descname">make_connectedbond_bond_bp</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_connectedbond_bond_bp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_gauinv">
<code class="descname">make_gauinv</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_gauinv" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a totally inefficient way of doing this
MolEmb should loop atoms.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_sym">
<code class="descname">make_sym</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_sym" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolDigesterEE.make_sym_update">
<code class="descname">make_sym_update</code><span class="sig-paren">(</span><em>mol</em>, <em>Rc=4.0</em>, <em>g1_para_mat=None</em>, <em>g2_para_mat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolDigesterEE.make_sym_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolGraph">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolGraph</code><span class="sig-paren">(</span><em>mol_</em>, <em>bond_length_thresh_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.MolGraph.AllAtomNames">
<code class="descname">AllAtomNames</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.AllAtomNames" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.AtomName">
<code class="descname">AtomName</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.AtomName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.AtomTypes">
<code class="descname">AtomTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.AtomTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.BondTypes">
<code class="descname">BondTypes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.BondTypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Calculate_Bond_Type">
<code class="descname">Calculate_Bond_Type</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Calculate_Bond_Type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Check_Connection">
<code class="descname">Check_Connection</code><span class="sig-paren">(</span><em>mol_node</em>, <em>frag_node</em>, <em>mol_visited_list</em>, <em>frag_visited_list</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Check_Connection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Compare_Node">
<code class="descname">Compare_Node</code><span class="sig-paren">(</span><em>mol_node</em>, <em>frag_node</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Compare_Node" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Connect_AtomNodes">
<code class="descname">Connect_AtomNodes</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Connect_AtomNodes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Find_Bond_Index">
<code class="descname">Find_Bond_Index</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Find_Bond_Index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Find_Frag">
<code class="descname">Find_Frag</code><span class="sig-paren">(</span><em>frag, ignored_ele=[1], frag_head=0, avail_atoms=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Find_Frag" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.GetNextNode_DFS">
<code class="descname">GetNextNode_DFS</code><span class="sig-paren">(</span><em>visited_list</em>, <em>node_stack</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.GetNextNode_DFS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.IsIsomer">
<code class="descname">IsIsomer</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.IsIsomer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Make_AtomNodes">
<code class="descname">Make_AtomNodes</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Make_AtomNodes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Make_Bonds">
<code class="descname">Make_Bonds</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Make_Bonds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.Make_Mol_Graph">
<code class="descname">Make_Mol_Graph</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.Make_Mol_Graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.NAtoms">
<code class="descname">NAtoms</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.NAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.NBonds">
<code class="descname">NBonds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.NBonds" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolGraph.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>mol_</em>, <em>bond_length_thresh_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolGraph.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>graph of a molecule</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolGraph.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.MolGraph'</em><a class="headerlink" href="#TensorMol.MolGraph.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFInstance.Instance</span></code></p>
<dl class="method">
<dt id="TensorMol.MolInstance.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=1250</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.Prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Called if only evaluations are being done, by evaluate()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstance'</em><a class="headerlink" href="#TensorMol.MolInstance.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>images</em>, <em>hidden1_units</em>, <em>hidden2_units</em>, <em>hidden3_units</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic inference routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>images</strong> &#8211; inputs placeholder.</li>
<li><strong>hidden1_units</strong> &#8211; Size of the first hidden layer.</li>
<li><strong>hidden2_units</strong> &#8211; Size of the second hidden layer.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output tensor.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">softmax_linear</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the loss from the logits and the labels.
Args:
logits: Logits tensor, float - [batch_size, NUM_CLASSES].
labels: Labels tensor, int32 - [batch_size].
Returns:
loss: Loss tensor of type float.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.train_step" title="Permalink to this definition">¶</a></dt>
<dd><p>I don&#8217;t think the base class should be train-able. Remove? JAP</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance_BP_Dipole">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance_BP_Dipole</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFMolInstance.MolInstance_fc_sqdiff_BP</span></code></p>
<p>Calculate the Dipole of Molecules</p>
<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.Eval_Prepare">
<code class="descname">Eval_Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.Eval_Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise a Behler-Parinello TensorFlow instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>TData</strong> &#8211; A TensorMolData instance.</li>
<li><strong>Name</strong> &#8211; A name for this instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance_BP_Dipole.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstanceEE'</em><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.continue_training">
<code class="descname">continue_training</code><span class="sig-paren">(</span><em>mxsteps</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.continue_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the tensorflow feed dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>batch_data</strong> &#8211; a list of numpy arrays containing inputs, bounds, matrices and desired energies in that order.</li>
<li><strong>placeholders to be assigned.</strong> (<em>and</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Filled feed dictionary.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>inp_pl</em>, <em>mats_pl</em>, <em>coords_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a Behler-Parinello graph which also matches monopole,3-dipole, and 9-quadropole elements.</p>
<ul class="simple">
<li>It has the shape of two energy networks in parallel.</li>
<li>One network produces the energy, the other produces the charge on an atom.</li>
<li>The charges are constrained to reproduce the molecular multipoles.</li>
<li>The energy and charge are together constrained to produce the molecular energy.</li>
<li>The same atomic linear transformation is used to produce the charges as the energy.</li>
<li>All multipoles have the form of a dot product with atomic charges. That&#8217;s pre-computed externally</li>
</ul>
<p>The attenuated coulomb energy has the form of a per-molecule vector-matrix-vector product.
And it is generated as well by this routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inp_pl</strong> &#8211; a list of (num_of atom type X flattened input shape) matrix of input cases.</li>
<li><strong>mats_pl</strong> &#8211; a list of (num_of atom type X batchsize) matrices which linearly combines the elements to give molecular outputs.</li>
<li><strong>mul_pl</strong> &#8211; Multipole inputs (see Mol::GenerateMultipoleInputs)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Atom BP Energy, Atom Charges
I&#8217;m thinking about doing the contractions for the multipoles and electrostatic energy loss in loss_op... haven&#8217;t settled on it yet.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>netcharge_output</em>, <em>dipole_output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>total_loss = scaler*l2(netcharge) + l2(dipole)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch_size</strong> &#8211; The batch size will be baked into both placeholders.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Input placeholder.
outputs_pl: Outputs placeholder.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">inputs_pl</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.test_after_training">
<code class="descname">test_after_training</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.test_after_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Get placeholders, graph and losses in order to begin training.
Also assigns the desired padding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>continue_training</strong> &#8211; should read the graph variables from a saved checkpoint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.train_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single training step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance_BP_Dipole_2">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance_BP_Dipole_2</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFMolInstanceEE.MolInstance_BP_Dipole</span></code></p>
<p>Calculate the Dipole of Molecules</p>
<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.Eval_Prepare">
<code class="descname">Eval_Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.Eval_Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise a Behler-Parinello TensorFlow instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>TData</strong> &#8211; A TensorMolData instance.</li>
<li><strong>Name</strong> &#8211; A name for this instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance_BP_Dipole_2.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstanceEE'</em><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.continue_training">
<code class="descname">continue_training</code><span class="sig-paren">(</span><em>mxsteps</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.continue_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the tensorflow feed dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>batch_data</strong> &#8211; a list of numpy arrays containing inputs, bounds, matrices and desired energies in that order.</li>
<li><strong>placeholders to be assigned.</strong> (<em>and</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Filled feed dictionary.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>inp_pl</em>, <em>mats_pl</em>, <em>coords_pl</em>, <em>natom_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a Behler-Parinello graph which also matches monopole,3-dipole, and 9-quadropole elements.</p>
<ul class="simple">
<li>It has the shape of two energy networks in parallel.</li>
<li>One network produces the energy, the other produces the charge on an atom.</li>
<li>The charges are constrained to reproduce the molecular multipoles.</li>
<li>The energy and charge are together constrained to produce the molecular energy.</li>
<li>The same atomic linear transformation is used to produce the charges as the energy.</li>
<li>All multipoles have the form of a dot product with atomic charges. That&#8217;s pre-computed externally</li>
</ul>
<p>The attenuated coulomb energy has the form of a per-molecule vector-matrix-vector product.
And it is generated as well by this routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inp_pl</strong> &#8211; a list of (num_of atom type X flattened input shape) matrix of input cases.</li>
<li><strong>mats_pl</strong> &#8211; a list of (num_of atom type X batchsize) matrices which linearly combines the elements to give molecular outputs.</li>
<li><strong>mul_pl</strong> &#8211; Multipole inputs (see Mol::GenerateMultipoleInputs)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Atom BP Energy, Atom Charges
I&#8217;m thinking about doing the contractions for the multipoles and electrostatic energy loss in loss_op... haven&#8217;t settled on it yet.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>dipole_output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>total_loss =  l2(dipole)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch_size</strong> &#8211; The batch size will be baked into both placeholders.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Input placeholder.
outputs_pl: Outputs placeholder.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">inputs_pl</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.test_after_training">
<code class="descname">test_after_training</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.test_after_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Get placeholders, graph and losses in order to begin training.
Also assigns the desired padding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>continue_training</strong> &#8211; should read the graph variables from a saved checkpoint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.train_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single training step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_BP_Dipole_2.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_BP_Dipole_2.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance_EE">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance_EE</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFMolInstance.MolInstance_fc_sqdiff_BP</span></code></p>
<p>A network with both energy and charge branches.
Loss is : l2(Energies)+l2(Dipole)
Network Yields: E_T,E_BP,E_electrostatic,Charges
Only neutral systems supported as of now.</p>
<p>This also uses TF&#8217;s new scatter/gathers/einsum
and Einsum to reduce the overhead of the BP scheme.</p>
<p>The whole energy is differentiable and can yield forces.
Requires TensorMolData_EE</p>
<p><a href="#id59"><span class="problematic" id="id60">E_</span></a>      ext{electrostatic} The electrostatic energy is attenuated to only exist
outside PARAMS[&#8220;EECutoff&#8221;]
# A couple cutoff schemes are available
PARAMS[&#8220;EESwitchFunc&#8221;]==&#8217;Cos&#8217;:</p>
<blockquote>
<div>1/r -&gt; (0.5*(cos(PI*r/EECutoff)+1))/r (if r&lt;Cutoff else 0)</div></blockquote>
<dl class="docutils">
<dt>PARAMS[&#8220;EESwitchFunc&#8221;]==&#8217;Tanh&#8217;</dt>
<dd>1/r =&gt; 0.5*(Tanh[(x - EECutoff)/EEdr] + 1)/r</dd>
</dl>
<dl class="method">
<dt id="TensorMol.MolInstance_EE.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.Eval_Prepare">
<code class="descname">Eval_Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.Eval_Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise a Behler-Parinello TensorFlow instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>TData</strong> &#8211; A TensorMolData instance.</li>
<li><strong>Name</strong> &#8211; A name for this instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance_EE.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstanceEE'</em><a class="headerlink" href="#TensorMol.MolInstance_EE.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.continue_training">
<code class="descname">continue_training</code><span class="sig-paren">(</span><em>mxsteps</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.continue_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the tensorflow feed dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>batch_data</strong> &#8211; a list of numpy arrays containing inputs, bounds, matrices and desired energies in that order.</li>
<li><strong>placeholders to be assigned.</strong> (<em>and</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Filled feed dictionary.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>inp_pl</em>, <em>mats_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a Behler-Parinello graph which also matches monopole,3-dipole, and 9-quadropole elements.</p>
<ul class="simple">
<li>It has the shape of two energy networks in parallel.</li>
<li>One network produces the energy, the other produces the charge on an atom.</li>
<li>The charges are constrained to reproduce the molecular multipoles.</li>
<li>The energy and charge are together constrained to produce the molecular energy.</li>
<li>The same atomic linear transformation is used to produce the charges as the energy.</li>
<li>All multipoles have the form of a dot product with atomic charges. That&#8217;s pre-computed externally</li>
</ul>
<p>The attenuated coulomb energy has the form of a per-molecule vector-matrix-vector product.
And it is generated as well by this routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inp_pl</strong> &#8211; a list of (num_of atom type X flattened input shape) matrix of input cases.</li>
<li><strong>mats_pl</strong> &#8211; a list of (num_of atom type X batchsize) matrices which linearly combines the elements to give molecular outputs.</li>
<li><strong>mul_pl</strong> &#8211; Multipole inputs (see Mol::GenerateMultipoleInputs)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Atom BP Energy, Atom Charges
I&#8217;m thinking about doing the contractions for the multipoles and electrostatic energy loss in loss_op... haven&#8217;t settled on it yet.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>E_mats</em>, <em>Q_mats</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>The loss operation of this model is complicated
Because you have to construct the electrostatic energy moleculewise,
and the mulitpoles.</p>
<p>Emats and Qmats are constructed to accerate this process...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch_size</strong> &#8211; The batch size will be baked into both placeholders.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Input placeholder.
outputs_pl: Outputs placeholder.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">inputs_pl</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.test_after_training">
<code class="descname">test_after_training</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.test_after_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Get placeholders, graph and losses in order to begin training.
Also assigns the desired padding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>continue_training</strong> &#8211; should read the graph variables from a saved checkpoint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.train_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single training step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_EE.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_EE.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance_LJForce">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance_LJForce</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFMolInstance.MolInstance_fc_sqdiff_BP</span></code></p>
<p>Optimizes a LJ force where pairs of atoms have specific
Epsilon and Re parameters.</p>
<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.Eval_Prepare">
<code class="descname">Eval_Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.Eval_Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.LJFrc">
<code class="descname">LJFrc</code><span class="sig-paren">(</span><em>inp_pl</em>, <em>keys_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.LJFrc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute forces for a batch of molecules
with the current LJe, and LJr.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inp_pl</strong> &#8211; placeholder for the NMol X MaxNatom X 4 tensor of Z,x,y,z</li>
<li><strong>keys_pl</strong> &#8211; placeholder for the NMol X MaxNatom molecule keys.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>TData</strong> &#8211; A TensorMolData instance.</li>
<li><strong>Name</strong> &#8211; A name for this instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance_LJForce.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstanceDirect'</em><a class="headerlink" href="#TensorMol.MolInstance_LJForce.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.continue_training">
<code class="descname">continue_training</code><span class="sig-paren">(</span><em>mxsteps</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.continue_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>batch_data</em>, <em>IfGrad=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the tensorflow feed dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>batch_data</strong> &#8211; a list of numpy arrays containing inputs, bounds, matrices and desired energies in that order.</li>
<li><strong>placeholders to be assigned.</strong> (<em>and</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Filled feed dictionary.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>inp_pl</em>, <em>mats_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a Behler-Parinello graph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inp_pl</strong> &#8211; a list of (num_of atom type X flattened input shape) matrix of input cases.</li>
<li><strong>mats_pl</strong> &#8211; a list of (num_of atom type X batchsize) matrices which linearly combines the elements</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The BP graph output</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>The loss operation of this model is complicated
Because you have to construct the electrostatic energy moleculewise,
and the mulitpoles.</p>
<p>Emats and Qmats are constructed to accerate this process...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch_size</strong> &#8211; The batch size will be baked into both placeholders.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Input placeholder.
outputs_pl: Outputs placeholder.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">inputs_pl</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.test_after_training">
<code class="descname">test_after_training</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.test_after_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps=10000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Get placeholders, graph and losses in order to begin training.
Also assigns the desired padding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>continue_training</strong> &#8211; should read the graph variables from a saved checkpoint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.train_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single training step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_LJForce.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_LJForce.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance_fc_classify">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance_fc_classify</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFMolInstance.MolInstance</span></code></p>
<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=125000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Translation of the outputs to meaningful numbers is handled by the digester and Tensordata</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance_fc_classify.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstance'</em><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>images</em>, <em>hidden1_units</em>, <em>hidden2_units</em>, <em>hidden3_units</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic inference routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>images</strong> &#8211; inputs placeholder.</li>
<li><strong>hidden1_units</strong> &#8211; Size of the first hidden layer.</li>
<li><strong>hidden2_units</strong> &#8211; Size of the second hidden layer.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output tensor.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">softmax_linear</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.justpreds">
<code class="descname">justpreds</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.justpreds" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the loss from the logits and the labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>logits</strong> &#8211; Logits tensor, float - [batch_size, NUM_CLASSES].</li>
<li><strong>labels</strong> &#8211; Labels tensor, int32 - [batch_size].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Loss tensor of type float.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">loss</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the loss from the logits and the labels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>logits</strong> &#8211; Logits tensor, float - [batch_size, NUM_CLASSES].</li>
<li><strong>labels</strong> &#8211; Labels tensor, int32 - [batch_size].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Loss tensor of type float.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">loss</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.n_correct">
<code class="descname">n_correct</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.n_correct" title="Permalink to this definition">¶</a></dt>
<dd><p>This should average over the classifier output.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.
These placeholders are used as inputs by the rest of the model building
code and will be fed from the downloaded data in the .run() loop.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch_size</strong> &#8211; The batch size will be baked into both placeholders.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Images placeholder.
labels_placeholder: Labels placeholder.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">images_placeholder</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>total_correct</em>, <em>Ncase</em>, <em>duration</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.train_step" title="Permalink to this definition">¶</a></dt>
<dd><p>I don&#8217;t think the base class should be train-able. Remove? JAP</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_classify.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_classify.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance_fc_sqdiff">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance_fc_sqdiff</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFMolInstance.MolInstance</span></code></p>
<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><em>eval_input</em>, <em>Ncase=125000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance_fc_sqdiff.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstance'</em><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>eval_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em>, <em>embeds_pl</em>, <em>labels_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the feed_dict for training the given step.
A feed_dict takes the form of:
feed_dict = {
&lt;placeholder&gt;: &lt;tensor of values to be passed for placeholder&gt;,
....
}
Args:
data_set: The set of images and labels, from input_data.read_data_sets()
embeds_pl: The images placeholder, from placeholder_inputs().
labels_pl: The labels placeholder, from placeholder_inputs().
Returns:
feed_dict: The feed dictionary mapping from placeholders to values.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>images</em>, <em>hidden1_units</em>, <em>hidden2_units</em>, <em>hidden3_units</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>A generic inference routine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>images</strong> &#8211; inputs placeholder.</li>
<li><strong>hidden1_units</strong> &#8211; Size of the first hidden layer.</li>
<li><strong>hidden2_units</strong> &#8211; Size of the second hidden layer.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Output tensor.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">softmax_linear</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.loss_op" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch_size</strong> &#8211; The batch size will be baked into both placeholders.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Input placeholder.
outputs_pl: Outputs placeholder.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">inputs_pl</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Train for a number of steps.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance_fc_sqdiff_BP</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFMolInstance.MolInstance_fc_sqdiff</span></code></p>
<p>An instance of A fully connected Behler-Parinello network.
Which requires a TensorMolData to train/execute.</p>
<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.Eval_Prepare">
<code class="descname">Eval_Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.Eval_Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise a Behler-Parinello TensorFlow instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>TData</strong> &#8211; A TensorMolData instance.</li>
<li><strong>Name</strong> &#8211; A name for this instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstance'</em><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.continue_training">
<code class="descname">continue_training</code><span class="sig-paren">(</span><em>mxsteps</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.continue_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>batch_data</em>, <em>IfGrad=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the tensorflow feed dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>batch_data</strong> &#8211; a list of numpy arrays containing inputs, bounds, matrices and desired energies in that order.</li>
<li><strong>placeholders to be assigned.</strong> (<em>and</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Filled feed dictionary.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><em>inp_pl</em>, <em>mats_pl</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a Behler-Parinello graph</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inp_pl</strong> &#8211; a list of (num_of atom type X flattened input shape) matrix of input cases.</li>
<li><strong>mats_pl</strong> &#8211; a list of (num_of atom type X batchsize) matrices which linearly combines the elements</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The BP graph output</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.loss_op" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch_size</strong> &#8211; The batch size will be baked into both placeholders.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Input placeholder.
outputs_pl: Outputs placeholder.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">inputs_pl</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.test_after_training">
<code class="descname">test_after_training</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.test_after_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Get placeholders, graph and losses in order to begin training.
Also assigns the desired padding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>continue_training</strong> &#8211; should read the graph variables from a saved checkpoint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.train_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single training step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">MolInstance_fc_sqdiff_BP_WithGrad</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFMolInstance.MolInstance_fc_sqdiff_BP</span></code></p>
<p>An instance of A fully connected Behler-Parinello network.
Which requires a TensorMolData_BP to train/execute.
This simultaneously constrains the gradient</p>
<p>Energy Inputs have dimension
[eles][atom case][Descriptor Dimension]
The inference is done elementwise.</p>
<p>Gradient inputs have dimension:
[eles][atom case][Descriptor Dimension][Max(n3)]</p>
<p>The desired outputs have dimension:
max(3n)+1 (energy and all derivatives, where max n3 is determined by training data.)</p>
<p>the molecular gradient is constructed by breaking up dE/dRx
dE/dRx  = sum_atoms dE_atom/dRx = sum_atoms dE_atom/dRx
the sum over atoms is done with the index matrices
after dE_atom/dRx is made elementwise in this way:
dE_atom/dRy = dE_atom/dD_i * dD_i/dRy</p>
<p>So dE_atom/dRy has dimension MaxN3</p>
<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.AssignActivation">
<code class="descname">AssignActivation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.AssignActivation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.Clean">
<code class="descname">Clean</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.Clean" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.Eval_Prepare">
<code class="descname">Eval_Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.Eval_Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.PrepareData">
<code class="descname">PrepareData</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.PrepareData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.SaveAndClose">
<code class="descname">SaveAndClose</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.SaveAndClose" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.__del__">
<code class="descname">__del__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.__del__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>TData_</em>, <em>Name_=None</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise a Behler-Parinello TensorFlow instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>TData</strong> &#8211; A TensorMolData instance.</li>
<li><strong>Name</strong> &#8211; A name for this instance.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolInstance'</em><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad._variable_with_weight_decay">
<code class="descname">_variable_with_weight_decay</code><span class="sig-paren">(</span><em>var_name</em>, <em>var_shape</em>, <em>var_stddev</em>, <em>var_wd</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad._variable_with_weight_decay" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper to create an initialized Variable with weight decay.</p>
<p>Note that the Variable is initialized with a truncated normal distribution.
A weight decay is added only if one is specified.</p>
<p>Args:
name: name of the variable
shape: list of ints
stddev: standard deviation of a truncated Gaussian
wd: add L2Loss weight decay multiplied by this float. If None, weight
decay is not added for this Variable.</p>
<p>Returns:
Variable Tensor</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.continue_training">
<code class="descname">continue_training</code><span class="sig-paren">(</span><em>mxsteps</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.continue_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>batch_data</em>, <em>IfGrad=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.fill_feed_dict">
<code class="descname">fill_feed_dict</code><span class="sig-paren">(</span><em>batch_data</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.fill_feed_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill the tensorflow feed dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>batch_data</strong> &#8211; a list of numpy arrays containing inputs, bounds, matrices and desired energies in that order.</li>
<li><strong>placeholders to be assigned.</strong> (<em>and</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Filled feed dictionary.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.inference">
<code class="descname">inference</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.inference" title="Permalink to this definition">¶</a></dt>
<dd><p>A separate inference routine should be made for
evaluation purposes because of MaxN3. This one is for training, specifically.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.loss_op">
<code class="descname">loss_op</code><span class="sig-paren">(</span><em>output</em>, <em>grads</em>, <em>labels</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.loss_op" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>output</strong> &#8211; energies of molecules.</li>
<li><strong>grads</strong> &#8211; gradients of molecules (MaxN3)</li>
<li><strong>labels</strong> &#8211; energy, gradients.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">l2 loss on the energies + self.GradWeight*l2 loss on gradients.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.placeholder_inputs">
<code class="descname">placeholder_inputs</code><span class="sig-paren">(</span><em>batch_size</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.placeholder_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate placeholder variables to represent the input tensors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch_size</strong> &#8211; The batch size will be baked into both placeholders.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Input placeholder.
outputs_pl: Outputs placeholder.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">inputs_pl</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.print_training">
<code class="descname">print_training</code><span class="sig-paren">(</span><em>step</em>, <em>loss</em>, <em>Ncase</em>, <em>duration</em>, <em>Train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.print_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.save_chk">
<code class="descname">save_chk</code><span class="sig-paren">(</span><em>step</em>, <em>feed_dict=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.save_chk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.test">
<code class="descname">test</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.test_after_training">
<code class="descname">test_after_training</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.test_after_training" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single test step (complete processing of all input), using minibatches of size self.batch_size</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step</strong> &#8211; the index of this step.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.train">
<code class="descname">train</code><span class="sig-paren">(</span><em>mxsteps</em>, <em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.train_prepare">
<code class="descname">train_prepare</code><span class="sig-paren">(</span><em>continue_training=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.train_prepare" title="Permalink to this definition">¶</a></dt>
<dd><p>Get placeholders, graph and losses in order to begin training.
Also assigns the desired padding.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>continue_training</strong> &#8211; should read the graph variables from a saved checkpoint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.train_step">
<code class="descname">train_step</code><span class="sig-paren">(</span><em>step</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.train_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.training">
<code class="descname">training</code><span class="sig-paren">(</span><em>loss</em>, <em>learning_rate</em>, <em>momentum</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.training" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets up the training Ops.
Creates a summarizer to track the loss over time in TensorBoard.
Creates an optimizer and applies the gradients to all trainable variables.
The Op returned by this function is what must be passed to the
<cite>sess.run()</cite> call to cause the model to train.
Args:
loss: Loss tensor, from loss().
learning_rate: The learning rate to use for gradient descent.
Returns:
train_op: The Op for training.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.variable_summaries">
<code class="descname">variable_summaries</code><span class="sig-paren">(</span><em>var</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MolInstance_fc_sqdiff_BP_WithGrad.variable_summaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Attach a lot of summaries to a Tensor (for TensorBoard visualization).</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.MorseKernel">
<code class="descclassname">TensorMol.</code><code class="descname">MorseKernel</code><span class="sig-paren">(</span><em>D</em>, <em>Z</em>, <em>Ae</em>, <em>De</em>, <em>Re</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.MorseKernel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>D</strong> &#8211; A square distance matrix (bohr)</li>
<li><strong>Z</strong> &#8211; Atomic Numbers.</li>
<li><strong>Ae</strong> &#8211; a matrix of force constants.</li>
<li><strong>De</strong> &#8211; a matrix of Morse De parameters. (MaxAtomicNumber X MaxAtomicNumber)</li>
<li><strong>Re</strong> &#8211; a matrix of</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.NormMatrices">
<code class="descclassname">TensorMol.</code><code class="descname">NormMatrices</code><span class="sig-paren">(</span><em>mat1</em>, <em>mat2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NormMatrices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.Normalize">
<code class="descclassname">TensorMol.</code><code class="descname">Normalize</code><span class="sig-paren">(</span><em>x_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Normalize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="TensorMol.NoseChainThermostat">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">NoseChainThermostat</code><span class="sig-paren">(</span><em>m_</em>, <em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseChainThermostat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.SimpleMD.Thermostat</span></code></p>
<dl class="method">
<dt id="TensorMol.NoseChainThermostat.IntegrateChain">
<code class="descname">IntegrateChain</code><span class="sig-paren">(</span><em>a_</em>, <em>x_</em>, <em>v_</em>, <em>m_</em>, <em>dt_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseChainThermostat.IntegrateChain" title="Permalink to this definition">¶</a></dt>
<dd><p>The Nose Hoover chain is twice trotterized in Martyna&#8217;s subroutine
So this evolves the chain a half-step, and updates <a href="#id61"><span class="problematic" id="id62">v_</span></a></p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.NoseChainThermostat.MartynaQs">
<code class="descname">MartynaQs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseChainThermostat.MartynaQs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NoseChainThermostat.Rescale">
<code class="descname">Rescale</code><span class="sig-paren">(</span><em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseChainThermostat.Rescale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NoseChainThermostat.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>m_</em>, <em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseChainThermostat.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity Verlet step with a Nose-Hoover Chain Thermostat.
Based on Appendix A of martyna 1996
<a class="reference external" href="http://dx.doi.org/10.1080/00268979600100761">http://dx.doi.org/10.1080/00268979600100761</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; an example of system positions.</li>
<li><strong>m</strong> &#8211; system masses.</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MNHChain&quot;</strong><strong>]</strong><strong></strong> &#8211; depth of the Nose Hoover Chain</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDTemp&quot;</strong><strong>]</strong><strong></strong> &#8211; Temperature of the Thermostat.</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDdt&quot;</strong><strong>]</strong><strong></strong> &#8211; Timestep of the dynamics.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.NoseChainThermostat.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.SimpleMD'</em><a class="headerlink" href="#TensorMol.NoseChainThermostat.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NoseChainThermostat.ke">
<code class="descname">ke</code><span class="sig-paren">(</span><em>v_</em>, <em>m_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseChainThermostat.ke" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NoseChainThermostat.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>f_</em>, <em>a_</em>, <em>x_</em>, <em>v_</em>, <em>m_</em>, <em>dt_</em>, <em>fande_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseChainThermostat.step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.NosePerParticleThermostat">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">NosePerParticleThermostat</code><span class="sig-paren">(</span><em>m_</em>, <em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NosePerParticleThermostat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.SimpleMD.Thermostat</span></code></p>
<dl class="method">
<dt id="TensorMol.NosePerParticleThermostat.Rescale">
<code class="descname">Rescale</code><span class="sig-paren">(</span><em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NosePerParticleThermostat.Rescale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NosePerParticleThermostat.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>m_</em>, <em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NosePerParticleThermostat.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>This</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.NosePerParticleThermostat.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.SimpleMD'</em><a class="headerlink" href="#TensorMol.NosePerParticleThermostat.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NosePerParticleThermostat.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>f_</em>, <em>a_</em>, <em>x_</em>, <em>v_</em>, <em>m_</em>, <em>dt_</em>, <em>fande_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NosePerParticleThermostat.step" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://www2.ph.ed.ac.uk/~dmarendu/MVP/MVP03.pdf">http://www2.ph.ed.ac.uk/~dmarendu/MVP/MVP03.pdf</a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.NoseThermostat">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">NoseThermostat</code><span class="sig-paren">(</span><em>m_</em>, <em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseThermostat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.SimpleMD.Thermostat</span></code></p>
<dl class="method">
<dt id="TensorMol.NoseThermostat.Rescale">
<code class="descname">Rescale</code><span class="sig-paren">(</span><em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseThermostat.Rescale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NoseThermostat.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>m_</em>, <em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseThermostat.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity Verlet step with a Nose-Hoover Thermostat.</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.NoseThermostat.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.SimpleMD'</em><a class="headerlink" href="#TensorMol.NoseThermostat.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NoseThermostat.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>f_</em>, <em>a_</em>, <em>x_</em>, <em>v_</em>, <em>m_</em>, <em>dt_</em>, <em>fande_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NoseThermostat.step" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="http://www2.ph.ed.ac.uk/~dmarendu/MVP/MVP03.pdf">http://www2.ph.ed.ac.uk/~dmarendu/MVP/MVP03.pdf</a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.NudgedElasticBand">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">NudgedElasticBand</code><span class="sig-paren">(</span><em>tfm_</em>, <em>g0_</em>, <em>g1_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.NudgedElasticBand.BeadAngleCosine">
<code class="descname">BeadAngleCosine</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.BeadAngleCosine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.CornerPenalty">
<code class="descname">CornerPenalty</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.CornerPenalty" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.HighQualityPES">
<code class="descname">HighQualityPES</code><span class="sig-paren">(</span><em>npts_=100</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.HighQualityPES" title="Permalink to this definition">¶</a></dt>
<dd><p>Do a high-quality integration of the path and forces.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.IntegrateEnergy">
<code class="descname">IntegrateEnergy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.IntegrateEnergy" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the fundamental theorem of line integrals to calculate an energy.
An interpolated path could improve this a lot.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.NebForce">
<code class="descname">NebForce</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.NebForce" title="Permalink to this definition">¶</a></dt>
<dd><p>This uses the mixing of Perpendicular spring force
to reduce kinks</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.OptNeb">
<code class="descname">OptNeb</code><span class="sig-paren">(</span><em>filename='Neb'</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.OptNeb" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.OptNebGLBFGS">
<code class="descname">OptNebGLBFGS</code><span class="sig-paren">(</span><em>filename='Neb'</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.OptNebGLBFGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize using a globalLBFGS
Some light code-borrowing from Kun&#8217;s MBE_Opt.py...</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.Parallel">
<code class="descname">Parallel</code><span class="sig-paren">(</span><em>v_</em>, <em>t_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.Parallel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.PauliForce">
<code class="descname">PauliForce</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.PauliForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Try to help-out HerrNet by preventing any type of collapses.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.Perpendicular">
<code class="descname">Perpendicular</code><span class="sig-paren">(</span><em>v_</em>, <em>t_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.Perpendicular" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.SpringDeriv">
<code class="descname">SpringDeriv</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.SpringDeriv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.Tangent">
<code class="descname">Tangent</code><span class="sig-paren">(</span><em>i</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.Tangent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.WriteTrajectory">
<code class="descname">WriteTrajectory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.WriteTrajectory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.NudgedElasticBand.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>tfm_</em>, <em>g0_</em>, <em>g1_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.NudgedElasticBand.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Nudged Elastic band. JCP 113 9978</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>tfm</strong> &#8211; a TFManager.</li>
<li><strong>g0</strong> &#8211; initial molecule.</li>
<li><strong>g1</strong> &#8211; final molecule.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A reaction path.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.NudgedElasticBand.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Neb'</em><a class="headerlink" href="#TensorMol.NudgedElasticBand.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.OctahedralOperations">
<code class="descclassname">TensorMol.</code><code class="descname">OctahedralOperations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.OctahedralOperations" title="Permalink to this definition">¶</a></dt>
<dd><p>Transformation matrices for symmetries of an octahedral shape.
Far from the complete set but enough for debugging and seeing if it helps.</p>
</dd></dl>

<dl class="class">
<dt id="TensorMol.Optimizer">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Optimizer</code><span class="sig-paren">(</span><em>tfm_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.Optimizer.CenterOfMass">
<code class="descname">CenterOfMass</code><span class="sig-paren">(</span><em>xyz</em>, <em>probs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.CenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.ChooseBest">
<code class="descname">ChooseBest</code><span class="sig-paren">(</span><em>xyz</em>, <em>probs</em>, <em>method='COM'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.ChooseBest" title="Permalink to this definition">¶</a></dt>
<dd><p>This routine actually belongs in the digester, because the digester knows the relationship between outputs and desired coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.GaussianConv">
<code class="descname">GaussianConv</code><span class="sig-paren">(</span><em>xyz</em>, <em>probs</em>, <em>width=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.GaussianConv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.GoOpt">
<code class="descname">GoOpt</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.GoOpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Tests if the Force of the Go-potential yields the equilibrium structure, which it totally does.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.GoOptProb">
<code class="descname">GoOptProb</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.GoOptProb" title="Permalink to this definition">¶</a></dt>
<dd><p>This version tests if the Go-opt converges when atoms are moved to
the points of mean-probability. CF POfAtomMoves()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.GoOpt_ScanForce">
<code class="descname">GoOpt_ScanForce</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.GoOpt_ScanForce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.Interpolate_OptForce">
<code class="descname">Interpolate_OptForce</code><span class="sig-paren">(</span><em>m1</em>, <em>m2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.Interpolate_OptForce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.LargestP">
<code class="descname">LargestP</code><span class="sig-paren">(</span><em>xyz</em>, <em>probs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.LargestP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.Opt">
<code class="descname">Opt</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.Opt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.OptANI1">
<code class="descname">OptANI1</code><span class="sig-paren">(</span><em>m</em>, <em>filename='OptLog'</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.OptANI1" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize using force output of an atomwise network.
now also averages over rotations...</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>m</strong> &#8211; A distorted molecule to optimize</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.OptGoForce">
<code class="descname">OptGoForce</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.OptGoForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple test of the Go-Force</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>m</strong> &#8211; A distorted molecule to optimize</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.OptLJForce">
<code class="descname">OptLJForce</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.OptLJForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple test of the LJ-Force
:param m: A distorted molecule to optimize</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.OptProb">
<code class="descname">OptProb</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.OptProb" title="Permalink to this definition">¶</a></dt>
<dd><p>This version tests if the Go-opt converges when atoms are moved to
the points of mean-probability. CF POfAtomMoves()</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.OptSmoothP">
<code class="descname">OptSmoothP</code><span class="sig-paren">(</span><em>m</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.OptSmoothP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.OptTFGoForce">
<code class="descname">OptTFGoForce</code><span class="sig-paren">(</span><em>m</em>, <em>Debug=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.OptTFGoForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize using force output of an atomwise network.
:param m: A distorted molecule to optimize</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.OptTFRealForce">
<code class="descname">OptTFRealForce</code><span class="sig-paren">(</span><em>m</em>, <em>filename='OptLog'</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.OptTFRealForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize using force output of an atomwise network.
now also averages over rotations...
:param m: A distorted molecule to optimize</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.OptTFRealForceLBFGS">
<code class="descname">OptTFRealForceLBFGS</code><span class="sig-paren">(</span><em>m</em>, <em>filename='OptLog'</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.OptTFRealForceLBFGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimize using force output of an atomwise network.
now also averages over rotations...
:param m: A distorted molecule to optimize</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.RemoveAverageTorque">
<code class="descname">RemoveAverageTorque</code><span class="sig-paren">(</span><em>velocs</em>, <em>coords</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.RemoveAverageTorque" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.SmallestP">
<code class="descname">SmallestP</code><span class="sig-paren">(</span><em>xyz</em>, <em>probs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.SmallestP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Optimizer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>tfm_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Optimizer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Geometry optimizations based on NN-PES&#8217;s etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tfm</strong> &#8211; a TFManage or TFMolManage instance to use as a molecular model.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.Optimizer.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Opt'</em><a class="headerlink" href="#TensorMol.Optimizer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.PairOrthogonalize">
<code class="descclassname">TensorMol.</code><code class="descname">PairOrthogonalize</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.PairOrthogonalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Does a Graham-Schmidt
The assumption here is that y is square and full-rank
and x has smaller and full rank. Returns rank(y)-rank(x) row vectors
which are all normalized and orthogonal to x.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.Pair_In_List">
<code class="descclassname">TensorMol.</code><code class="descname">Pair_In_List</code><span class="sig-paren">(</span><em>l</em>, <em>pairs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Pair_In_List" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.PointsNear">
<code class="descclassname">TensorMol.</code><code class="descname">PointsNear</code><span class="sig-paren">(</span><em>point</em>, <em>NPts</em>, <em>Dist</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.PointsNear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.PseudoInverse">
<code class="descclassname">TensorMol.</code><code class="descname">PseudoInverse</code><span class="sig-paren">(</span><em>mat_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.PseudoInverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.PyscfDft">
<code class="descclassname">TensorMol.</code><code class="descname">PyscfDft</code><span class="sig-paren">(</span><em>m_</em>, <em>basis_='6-31g*'</em>, <em>xc_='b3lyp'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.PyscfDft" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.QchemDft">
<code class="descclassname">TensorMol.</code><code class="descname">QchemDft</code><span class="sig-paren">(</span><em>m_</em>, <em>basis_='6-31g*'</em>, <em>xc_='b3lyp'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.QchemDft" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.ReflectionMatrix">
<code class="descclassname">TensorMol.</code><code class="descname">ReflectionMatrix</code><span class="sig-paren">(</span><em>axis1</em>, <em>axis2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.ReflectionMatrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.RemoveInvariantForce">
<code class="descclassname">TensorMol.</code><code class="descname">RemoveInvariantForce</code><span class="sig-paren">(</span><em>x_</em>, <em>f_</em>, <em>m_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.RemoveInvariantForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes center of mass motion and torque from <a href="#id63"><span class="problematic" id="id64">f_</span></a>, and returns the invariant bits.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.ReverseAtomwiseEmbedding">
<code class="descclassname">TensorMol.</code><code class="descname">ReverseAtomwiseEmbedding</code><span class="sig-paren">(</span><em>dig_</em>, <em>emb_</em>, <em>atoms_=None</em>, <em>guess_=None</em>, <em>GdDistMatrix=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.ReverseAtomwiseEmbedding" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>atoms</strong> &#8211; a list of element types for which this routine provides coords.</li>
<li><strong>dig</strong> &#8211; a digester</li>
<li><strong>emb</strong> &#8211; the embedding which we will try to construct a mol to match. Because this is atomwise this will actually be a (natom X embedding shape) tensor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A best-fit version of a molecule which produces an embedding as close to <a href="#id65"><span class="problematic" id="id66">emb_</span></a> as possible.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.RmsForce">
<code class="descclassname">TensorMol.</code><code class="descname">RmsForce</code><span class="sig-paren">(</span><em>f_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.RmsForce" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.RotationMatrix">
<code class="descclassname">TensorMol.</code><code class="descname">RotationMatrix</code><span class="sig-paren">(</span><em>axis</em>, <em>theta</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.RotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the rotation matrix associated with counterclockwise rotation about
the given axis by theta radians.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.RotationMatrix_v2">
<code class="descclassname">TensorMol.</code><code class="descname">RotationMatrix_v2</code><span class="sig-paren">(</span><em>randnums=None</em>, <em>deflection=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.RotationMatrix_v2" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a uniformly random rotation matrix
:param randnums: theta, phi, and z for rotation, if None then chosen uniformly random
:param deflection: magnitude of rotation, 0 is no rotation, 1 is completely random rotation, inbetween are perturbations</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.SamplingFunc_v2">
<code class="descclassname">TensorMol.</code><code class="descname">SamplingFunc_v2</code><span class="sig-paren">(</span><em>S</em>, <em>maxdisp</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.SamplingFunc_v2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.SchmidtStep">
<code class="descclassname">TensorMol.</code><code class="descname">SchmidtStep</code><span class="sig-paren">(</span><em>xs</em>, <em>y_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.SchmidtStep" title="Permalink to this definition">¶</a></dt>
<dd><p>return y - projection of y onto all xs normalized.
:param xs: orthonormal row vectors
:param y: another row vector.</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.Setdiff">
<code class="descclassname">TensorMol.</code><code class="descname">Setdiff</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Setdiff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.SignStep">
<code class="descclassname">TensorMol.</code><code class="descname">SignStep</code><span class="sig-paren">(</span><em>S</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.SignStep" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.SphereToCart">
<code class="descclassname">TensorMol.</code><code class="descname">SphereToCart</code><span class="sig-paren">(</span><em>arg_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.SphereToCart" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.SphereToCartV">
<code class="descclassname">TensorMol.</code><code class="descname">SphereToCartV</code><span class="sig-paren">(</span><em>arg_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.SphereToCartV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.String_To_Atoms">
<code class="descclassname">TensorMol.</code><code class="descname">String_To_Atoms</code><span class="sig-paren">(</span><em>s=''</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.String_To_Atoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.Submit_Script_Lines">
<code class="descclassname">TensorMol.</code><code class="descname">Submit_Script_Lines</code><span class="sig-paren">(</span><em>order='3'</em>, <em>sub_order='1'</em>, <em>index='1'</em>, <em>mincase='0'</em>, <em>maxcase='1000'</em>, <em>name='MBE'</em>, <em>ncore='4'</em>, <em>queue='long'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Submit_Script_Lines" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.Subset">
<code class="descclassname">TensorMol.</code><code class="descname">Subset</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Subset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.TFDistance">
<code class="descclassname">TensorMol.</code><code class="descname">TFDistance</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFDistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a distance matrix of A, a coordinate matrix
Using the factorization:
Dij = &lt;i|i&gt; - 2&lt;i|j&gt; + &lt;j,j&gt;
:param A: a Nx3 matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a NxN matrix</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">D</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.TFDistances">
<code class="descclassname">TensorMol.</code><code class="descname">TFDistances</code><span class="sig-paren">(</span><em>r_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFDistances" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns distance matrices batched over mols
:param <a href="#id67"><span class="problematic" id="id68">r_</span></a>: Nmol X MaxNAtom X 3 coordinate tensor</p>
<dl class="docutils">
<dt>Returns</dt>
<dd>D: Nmol X MaxNAtom X MaxNAtom Distance tensor.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="TensorMol.TFManage">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TFManage</code><span class="sig-paren">(</span><em>Name_=''</em>, <em>TData_=None</em>, <em>Train_=True</em>, <em>NetType_='fc_sqdiff'</em>, <em>RandomTData_=True</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage" title="Permalink to this definition">¶</a></dt>
<dd><p>A manager of tensorflow instances which perform atom-wise predictions
and parent of the molecular instance mangager.</p>
<dl class="method">
<dt id="TensorMol.TFManage.EvalAllAtoms">
<code class="descname">EvalAllAtoms</code><span class="sig-paren">(</span><em>mol</em>, <em>maxstep=1.5</em>, <em>ngrid=50</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalAllAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalAllAtomsMB">
<code class="descname">EvalAllAtomsMB</code><span class="sig-paren">(</span><em>mol</em>, <em>maxstep=0.2</em>, <em>ngrid=50</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalAllAtomsMB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalElement">
<code class="descname">EvalElement</code><span class="sig-paren">(</span><em>ele</em>, <em>test_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalMol">
<code class="descname">EvalMol</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalMol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalMol_v2">
<code class="descname">EvalMol_v2</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalMol_v2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalOctAvForce">
<code class="descname">EvalOctAvForce</code><span class="sig-paren">(</span><em>mol</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalOctAvForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Goes without saying we should do this in batches for each element,
if it actually improves accuracy. And improve rotational sampling.
But for the time being I&#8217;m doing this sloppily.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalOneAtom">
<code class="descname">EvalOneAtom</code><span class="sig-paren">(</span><em>mol</em>, <em>atom</em>, <em>maxstep=0.2</em>, <em>ngrid=50</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalOneAtom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalOneAtomMB">
<code class="descname">EvalOneAtomMB</code><span class="sig-paren">(</span><em>mol</em>, <em>atom</em>, <em>maxstep=0.2</em>, <em>ngrid=50</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalOneAtomMB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalRotAvForce">
<code class="descname">EvalRotAvForce</code><span class="sig-paren">(</span><em>mol</em>, <em>RotAv=10</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalRotAvForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewritten for optimal performance with rotational averaging and atom ordering.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.EvalRotAvForceOld">
<code class="descname">EvalRotAvForceOld</code><span class="sig-paren">(</span><em>mol</em>, <em>RotAv=10</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.EvalRotAvForceOld" title="Permalink to this definition">¶</a></dt>
<dd><p>Goes without saying we should do this in batches for each element,
if it actually improves accuracy. And improve rotational sampling.
But for the time being I&#8217;m doing this sloppily.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.Print">
<code class="descname">Print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.Print" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.SampleAtomGrid">
<code class="descname">SampleAtomGrid</code><span class="sig-paren">(</span><em>mol</em>, <em>atom</em>, <em>maxstep</em>, <em>ngrid</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.SampleAtomGrid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.SmoothPOneAtom">
<code class="descname">SmoothPOneAtom</code><span class="sig-paren">(</span><em>mol_</em>, <em>atom_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.SmoothPOneAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses smooth fitting of Go probability to pick the next point as predicted by the network
This should eventually be made faster by doing all atoms of an element type at once.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.Train">
<code class="descname">Train</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.Train" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.TrainElement">
<code class="descname">TrainElement</code><span class="sig-paren">(</span><em>ele</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.TrainElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>Name_=''</em>, <em>TData_=None</em>, <em>Train_=True</em>, <em>NetType_='fc_sqdiff'</em>, <em>RandomTData_=True</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Name</strong> &#8211; If not blank, will try to load a network with that name using Prepare()</li>
<li><strong>TData</strong> &#8211; A TensorData instance to provide and process data.</li>
<li><strong>Train</strong> &#8211; Whether to train the instances raised.</li>
<li><strong>NetType</strong> &#8211; Choices of Various network architectures.</li>
<li><strong>RandomTData</strong> &#8211; Modifes the preparation of training batches.</li>
<li><strong>ntrain</strong> &#8211; Number of steps to train an element.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TFManage.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFManage'</em><a class="headerlink" href="#TensorMol.TFManage.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFManage.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>mol</em>, <em>atom</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFManage.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.TFMolManage">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TFMolManage</code><span class="sig-paren">(</span><em>Name_=''</em>, <em>TData_=None</em>, <em>Train_=False</em>, <em>NetType_='fc_sqdiff'</em>, <em>RandomTData_=True</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TFManage.TFManage</span></code></p>
<p>A manager of tensorflow instances which perform molecule-wise predictions
including Many Body and Behler-Parinello</p>
<dl class="method">
<dt id="TensorMol.TFMolManage.Continue_Training">
<code class="descname">Continue_Training</code><span class="sig-paren">(</span><em>maxsteps</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Continue_Training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval">
<code class="descname">Eval</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalAllAtoms">
<code class="descname">EvalAllAtoms</code><span class="sig-paren">(</span><em>mol</em>, <em>maxstep=1.5</em>, <em>ngrid=50</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalAllAtoms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalAllAtomsMB">
<code class="descname">EvalAllAtomsMB</code><span class="sig-paren">(</span><em>mol</em>, <em>maxstep=0.2</em>, <em>ngrid=50</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalAllAtomsMB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalElement">
<code class="descname">EvalElement</code><span class="sig-paren">(</span><em>ele</em>, <em>test_input</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalMol">
<code class="descname">EvalMol</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalMol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalMol_v2">
<code class="descname">EvalMol_v2</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalMol_v2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalOctAvForce">
<code class="descname">EvalOctAvForce</code><span class="sig-paren">(</span><em>mol</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalOctAvForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Goes without saying we should do this in batches for each element,
if it actually improves accuracy. And improve rotational sampling.
But for the time being I&#8217;m doing this sloppily.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalOneAtom">
<code class="descname">EvalOneAtom</code><span class="sig-paren">(</span><em>mol</em>, <em>atom</em>, <em>maxstep=0.2</em>, <em>ngrid=50</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalOneAtom" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalOneAtomMB">
<code class="descname">EvalOneAtomMB</code><span class="sig-paren">(</span><em>mol</em>, <em>atom</em>, <em>maxstep=0.2</em>, <em>ngrid=50</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalOneAtomMB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalRotAvForce">
<code class="descname">EvalRotAvForce</code><span class="sig-paren">(</span><em>mol</em>, <em>RotAv=10</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalRotAvForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Rewritten for optimal performance with rotational averaging and atom ordering.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.EvalRotAvForceOld">
<code class="descname">EvalRotAvForceOld</code><span class="sig-paren">(</span><em>mol</em>, <em>RotAv=10</em>, <em>Debug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.EvalRotAvForceOld" title="Permalink to this definition">¶</a></dt>
<dd><p>Goes without saying we should do this in batches for each element,
if it actually improves accuracy. And improve rotational sampling.
But for the time being I&#8217;m doing this sloppily.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_BPDipole">
<code class="descname">Eval_BPDipole</code><span class="sig-paren">(</span><em>mol_set</em>, <em>ScaleCharge_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_BPDipole" title="Permalink to this definition">¶</a></dt>
<dd><p>can take either a single mol or mol set
return netcharge, dipole, atomcharge
Dipole has unit in debye</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_BPDipole_2">
<code class="descname">Eval_BPDipole_2</code><span class="sig-paren">(</span><em>mol_set</em>, <em>ScaleCharge_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_BPDipole_2" title="Permalink to this definition">¶</a></dt>
<dd><p>can take either a single mol or mol set
return dipole, atomcharge
Dipole has unit in debye</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_BPEnergy">
<code class="descname">Eval_BPEnergy</code><span class="sig-paren">(</span><em>mol_set</em>, <em>total_energy=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_BPEnergy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_BPEnergySingle">
<code class="descname">Eval_BPEnergySingle</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_BPEnergySingle" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>mol</strong> &#8211; a Mol.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Energy in Hartree</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_BPForceHalfNumerical">
<code class="descname">Eval_BPForceHalfNumerical</code><span class="sig-paren">(</span><em>mol</em>, <em>total_energy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_BPForceHalfNumerical" title="Permalink to this definition">¶</a></dt>
<dd><p>This version uses a half-numerical gradient.
It was written for debugging purposes.
:param mol: a Mol.
:param total_energy: whether to also return the energy as a first argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Energy in Hartree
and Forces (kcal/mol)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(if total_energy == True)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_BPForceSingle">
<code class="descname">Eval_BPForceSingle</code><span class="sig-paren">(</span><em>mol</em>, <em>total_energy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_BPForceSingle" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol</strong> &#8211; a Mol.</li>
<li><strong>total_energy</strong> &#8211; whether to also return the energy as a first argument.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Energy in Hartree
and Forces (J/mol)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(if total_energy == True)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_Bond_BP">
<code class="descname">Eval_Bond_BP</code><span class="sig-paren">(</span><em>mol_set</em>, <em>total_energy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_Bond_BP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_Input">
<code class="descname">Eval_Input</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_Input" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol</strong> &#8211; a Mol.</li>
<li><strong>total_energy</strong> &#8211; whether to also return the energy as a first argument.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Energy in Hartree
and Forces (kcal/mol)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(if total_energy == True)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_InputGrad">
<code class="descname">Eval_InputGrad</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_InputGrad" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mol</strong> &#8211; a Mol.</li>
<li><strong>total_energy</strong> &#8211; whether to also return the energy as a first argument.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Energy in Hartree
and Forces (kcal/mol)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(if total_energy == True)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Eval_Mol">
<code class="descname">Eval_Mol</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Eval_Mol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Prepare">
<code class="descname">Prepare</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Prepare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Print">
<code class="descname">Print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Print" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.SampleAtomGrid">
<code class="descname">SampleAtomGrid</code><span class="sig-paren">(</span><em>mol</em>, <em>atom</em>, <em>maxstep</em>, <em>ngrid</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.SampleAtomGrid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.SmoothPOneAtom">
<code class="descname">SmoothPOneAtom</code><span class="sig-paren">(</span><em>mol_</em>, <em>atom_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.SmoothPOneAtom" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses smooth fitting of Go probability to pick the next point as predicted by the network
This should eventually be made faster by doing all atoms of an element type at once.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Test">
<code class="descname">Test</code><span class="sig-paren">(</span><em>save_file='mbe_test.dat'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Test" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Test_BPGrad">
<code class="descname">Test_BPGrad</code><span class="sig-paren">(</span><em>mol</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Test_BPGrad" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the gradient a couple different ways. Compares them.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.Train">
<code class="descname">Train</code><span class="sig-paren">(</span><em>maxstep=3000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.Train" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiates and trains a Molecular network.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>maxstep</strong> &#8211; The number of training steps.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.TrainElement">
<code class="descname">TrainElement</code><span class="sig-paren">(</span><em>ele</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.TrainElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>Name_=''</em>, <em>TData_=None</em>, <em>Train_=False</em>, <em>NetType_='fc_sqdiff'</em>, <em>RandomTData_=True</em>, <em>Trainable_=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Name</strong> &#8211; If not blank, will try to load a network with that name using Prepare()</li>
<li><strong>TData</strong> &#8211; A TensorMolData instance to provide and process data.</li>
<li><strong>Train</strong> &#8211; Whether to train the instances raised.</li>
<li><strong>NetType</strong> &#8211; Choices of Various network architectures.</li>
<li><strong>RandomTData</strong> &#8211; Modifes the preparation of training batches.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TFMolManage.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TFMolManage'</em><a class="headerlink" href="#TensorMol.TFMolManage.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TFMolManage.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>mol</em>, <em>atom</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TFMolManage.evaluate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.TMBanner">
<code class="descclassname">TensorMol.</code><code class="descname">TMBanner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMBanner" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.TMLogger">
<code class="descclassname">TensorMol.</code><code class="descname">TMLogger</code><span class="sig-paren">(</span><em>path_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMLogger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="TensorMol.TMParams">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TMParams</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMParams" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">dict</span></code></p>
<dl class="attribute">
<dt id="TensorMol.TMParams.__class__">
<code class="descname">__class__</code><a class="headerlink" href="#TensorMol.TMParams.__class__" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal"><span class="pre">type</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__cmp__">
<code class="descname">__cmp__</code><a class="headerlink" href="#TensorMol.TMParams.__cmp__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span> &rarr; True if D has a key k, else False<a class="headerlink" href="#TensorMol.TMParams.__contains__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__delattr__">
<code class="descname">__delattr__</code><a class="headerlink" href="#TensorMol.TMParams.__delattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__delattr__(&#8216;name&#8217;) &lt;==&gt; del x.name</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__delitem__">
<code class="descname">__delitem__</code><a class="headerlink" href="#TensorMol.TMParams.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__delitem__(y) &lt;==&gt; del x[y]</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__dict__">
<code class="descname">__dict__</code><em class="property"> = dict_proxy({'__module__': 'TensorMol.TMParams', '__str__': &lt;function __str__&gt;, '__dict__': &lt;attribute '__dict__' of 'TMParams' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'TMParams' objects&gt;, '__doc__': None, '__init__': &lt;function __init__&gt;})</em><a class="headerlink" href="#TensorMol.TMParams.__dict__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__eq__">
<code class="descname">__eq__</code><a class="headerlink" href="#TensorMol.TMParams.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__eq__(y) &lt;==&gt; x==y</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__format__">
<code class="descname">__format__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMParams.__format__" title="Permalink to this definition">¶</a></dt>
<dd><p>default object formatter</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__ge__">
<code class="descname">__ge__</code><a class="headerlink" href="#TensorMol.TMParams.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__ge__(y) &lt;==&gt; x&gt;=y</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__getattribute__">
<code class="descname">__getattribute__</code><a class="headerlink" href="#TensorMol.TMParams.__getattribute__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__getattribute__(&#8216;name&#8217;) &lt;==&gt; x.name</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMParams.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__getitem__(y) &lt;==&gt; x[y]</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__gt__">
<code class="descname">__gt__</code><a class="headerlink" href="#TensorMol.TMParams.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__gt__(y) &lt;==&gt; x&gt;y</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__hash__">
<code class="descname">__hash__</code><em class="property"> = None</em><a class="headerlink" href="#TensorMol.TMParams.__hash__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMParams.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__iter__">
<code class="descname">__iter__</code><a class="headerlink" href="#TensorMol.TMParams.__iter__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__le__">
<code class="descname">__le__</code><a class="headerlink" href="#TensorMol.TMParams.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__le__(y) &lt;==&gt; x&lt;=y</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__len__">
<code class="descname">__len__</code><a class="headerlink" href="#TensorMol.TMParams.__len__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__lt__">
<code class="descname">__lt__</code><a class="headerlink" href="#TensorMol.TMParams.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__lt__(y) &lt;==&gt; x&lt;y</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TMParams'</em><a class="headerlink" href="#TensorMol.TMParams.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__ne__">
<code class="descname">__ne__</code><a class="headerlink" href="#TensorMol.TMParams.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__ne__(y) &lt;==&gt; x!=y</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__new__">
<code class="descname">__new__</code><span class="sig-paren">(</span><em>S</em>, <em>...</em><span class="sig-paren">)</span> &rarr; a new object with type S, a subtype of T<a class="headerlink" href="#TensorMol.TMParams.__new__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__reduce__">
<code class="descname">__reduce__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMParams.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for pickle</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__reduce_ex__">
<code class="descname">__reduce_ex__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMParams.__reduce_ex__" title="Permalink to this definition">¶</a></dt>
<dd><p>helper for pickle</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__repr__">
<code class="descname">__repr__</code><a class="headerlink" href="#TensorMol.TMParams.__repr__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__setattr__">
<code class="descname">__setattr__</code><a class="headerlink" href="#TensorMol.TMParams.__setattr__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__setattr__(&#8216;name&#8217;, value) &lt;==&gt; x.name = value</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__setitem__">
<code class="descname">__setitem__</code><a class="headerlink" href="#TensorMol.TMParams.__setitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__setitem__(i, y) &lt;==&gt; x[i]=y</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__sizeof__">
<code class="descname">__sizeof__</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; size of D in memory, in bytes<a class="headerlink" href="#TensorMol.TMParams.__sizeof__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__str__">
<code class="descname">__str__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMParams.__str__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.__subclasshook__">
<code class="descname">__subclasshook__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TMParams.__subclasshook__" title="Permalink to this definition">¶</a></dt>
<dd><p>Abstract classes can override this to customize issubclass().</p>
<p>This is invoked early on by abc.ABCMeta.__subclasscheck__().
It should return True, False or NotImplemented.  If it returns
NotImplemented, the normal algorithm is used.  Otherwise, it
overrides the normal algorithm (and the outcome is cached).</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TMParams.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#TensorMol.TMParams.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; None.  Remove all items from D.<a class="headerlink" href="#TensorMol.TMParams.clear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; a shallow copy of D<a class="headerlink" href="#TensorMol.TMParams.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.fromkeys">
<code class="descname">fromkeys</code><span class="sig-paren">(</span><em>S</em><span class="optional">[</span>, <em>v</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; New dict with keys from S and values equal to v.<a class="headerlink" href="#TensorMol.TMParams.fromkeys" title="Permalink to this definition">¶</a></dt>
<dd><p>v defaults to None.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; D[k] if k in D, else d.  d defaults to None.<a class="headerlink" href="#TensorMol.TMParams.get" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.has_key">
<code class="descname">has_key</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span> &rarr; True if D has a key k, else False<a class="headerlink" href="#TensorMol.TMParams.has_key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.items">
<code class="descname">items</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; list of D's (key, value) pairs, as 2-tuples<a class="headerlink" href="#TensorMol.TMParams.items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.iteritems">
<code class="descname">iteritems</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; an iterator over the (key, value) items of D<a class="headerlink" href="#TensorMol.TMParams.iteritems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.iterkeys">
<code class="descname">iterkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; an iterator over the keys of D<a class="headerlink" href="#TensorMol.TMParams.iterkeys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.itervalues">
<code class="descname">itervalues</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; an iterator over the values of D<a class="headerlink" href="#TensorMol.TMParams.itervalues" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.keys">
<code class="descname">keys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; list of D's keys<a class="headerlink" href="#TensorMol.TMParams.keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.pop">
<code class="descname">pop</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; v, remove specified key and return the corresponding value.<a class="headerlink" href="#TensorMol.TMParams.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>If key is not found, d is returned if given, otherwise KeyError is raised</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.popitem">
<code class="descname">popitem</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; (k, v), remove and return some (key, value) pair as a<a class="headerlink" href="#TensorMol.TMParams.popitem" title="Permalink to this definition">¶</a></dt>
<dd><p>2-tuple; but raise KeyError if D is empty.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.setdefault">
<code class="descname">setdefault</code><span class="sig-paren">(</span><em>k</em><span class="optional">[</span>, <em>d</em><span class="optional">]</span><span class="sig-paren">)</span> &rarr; D.get(k,d), also set D[k]=d if k not in D<a class="headerlink" href="#TensorMol.TMParams.setdefault" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.update">
<code class="descname">update</code><span class="sig-paren">(</span><span class="optional">[</span><em>E</em>, <span class="optional">]</span><em>**F</em><span class="sig-paren">)</span> &rarr; None.  Update D from dict/iterable E and F.<a class="headerlink" href="#TensorMol.TMParams.update" title="Permalink to this definition">¶</a></dt>
<dd><p>If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k in F: D[k] = F[k]</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.values">
<code class="descname">values</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; list of D's values<a class="headerlink" href="#TensorMol.TMParams.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.viewitems">
<code class="descname">viewitems</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; a set-like object providing a view on D's items<a class="headerlink" href="#TensorMol.TMParams.viewitems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.viewkeys">
<code class="descname">viewkeys</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; a set-like object providing a view on D's keys<a class="headerlink" href="#TensorMol.TMParams.viewkeys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TMParams.viewvalues">
<code class="descname">viewvalues</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &rarr; an object providing a view on D's values<a class="headerlink" href="#TensorMol.TMParams.viewvalues" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.TanhKernelLR">
<code class="descclassname">TensorMol.</code><code class="descname">TanhKernelLR</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TanhKernelLR" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>D</strong> &#8211; A square distance matrix (bohr)</li>
<li><strong>=&gt; 1/r =&gt; 0.5*</strong> (<em>'Tanh'</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.TanhKernelSR">
<code class="descclassname">TensorMol.</code><code class="descname">TanhKernelSR</code><span class="sig-paren">(</span><em>D</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TanhKernelSR" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>D</strong> &#8211; A square distance matrix (bohr)</li>
<li><strong>=&gt; 1/r =&gt; 0.5*</strong> (<em>'Tanh'</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="TensorMol.TensorData">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TensorData</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>type_='atom'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData" title="Permalink to this definition">¶</a></dt>
<dd><p>A Training Set is a Molecule set, with a sampler and an embedding
The sampler chooses points in the molecular volume.
The embedding turns that into inputs and labels for a network to regress.</p>
<dl class="method">
<dt id="TensorMol.TensorData.BuildSamples">
<code class="descname">BuildSamples</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>uniform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.BuildSamples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sampled data set without preparing the probabilities or embedding
if uniform is true, it generate a grid of uniform samples up to 4 angstrom away from
the central atom to generate known-good validation data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.BuildTrain">
<code class="descname">BuildTrain</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>append=False</em>, <em>MakeDebug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.BuildTrain" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates probability inputs for all training data using the chosen digester.
All the inputs for a given atom are built separately.
Now requires some sort of PES information.
If PESSamples = [] it will use a Go-model (CITE:http://dx.doi.org/10.1016/S0006-3495(02)75308-3)
The code that uses ab-initio samples isn&#8217;t written yet, but should be.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.BuildTrainMolwise">
<code class="descname">BuildTrainMolwise</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>append=False</em>, <em>MakeDebug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.BuildTrainMolwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates inputs for all training data using the chosen digester.
This version builds all the elements at the same time.
The other version builds each element separately
If PESSamples = [] it may use a Go-model (CITE:http://dx.doi.org/10.1016/S0006-3495(02)75308-3)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.CheckShapes">
<code class="descname">CheckShapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.CheckShapes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.CleanScratch">
<code class="descname">CleanScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.CleanScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.EvaluateTestBatch">
<code class="descname">EvaluateTestBatch</code><span class="sig-paren">(</span><em>desired</em>, <em>predicted</em>, <em>tformer</em>, <em>Opt=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.EvaluateTestBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.GetTestBatch">
<code class="descname">GetTestBatch</code><span class="sig-paren">(</span><em>ele</em>, <em>ncases=200</em>, <em>ministep=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.GetTestBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.GetTrainBatch">
<code class="descname">GetTrainBatch</code><span class="sig-paren">(</span><em>ele</em>, <em>ncases=2000</em>, <em>random=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.GetTrainBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.LoadElement">
<code class="descname">LoadElement</code><span class="sig-paren">(</span><em>ele</em>, <em>Random=True</em>, <em>DebugData_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.LoadElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.LoadElementToScratch">
<code class="descname">LoadElementToScratch</code><span class="sig-paren">(</span><em>ele</em>, <em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.LoadElementToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.
note that modifies my MolDigester to incorporate the normalization
Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.MergeWith">
<code class="descname">MergeWith</code><span class="sig-paren">(</span><em>ASet_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.MergeWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Augments my training data with another set, which for example may have been generated on another computer.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.NTestCasesInScratch">
<code class="descname">NTestCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.NTestCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.NTrainCasesInScratch">
<code class="descname">NTrainCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.NTrainCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.PrintSampleInformation">
<code class="descname">PrintSampleInformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.PrintSampleInformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.PrintStatus">
<code class="descname">PrintStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.PrintStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.QueryAvailable">
<code class="descname">QueryAvailable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.QueryAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>If Tensordata has already been made, this looks for it under a passed name.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.ReloadSet">
<code class="descname">ReloadSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.ReloadSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalls the MSet to build training data etc.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>type_='atom'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>make a tensordata object
Several arguments of PARAMS affect this classes behavior</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>MSet</strong> &#8211; A MoleculeSet</li>
<li><strong>Dig</strong> &#8211; A Digester</li>
<li><strong>Name</strong> &#8211; A Name</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TensorData.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TensorData'</em><a class="headerlink" href="#TensorMol.TensorData.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.TensorMolData">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TensorMolData</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TensorData.TensorData</span></code></p>
<p>A Training Set is a Molecule set, with a sampler and an embedding
The sampler chooses points in the molecular volume.
The embedding turns that into inputs and labels for a network to regress.</p>
<dl class="method">
<dt id="TensorMol.TensorMolData.BuildSamples">
<code class="descname">BuildSamples</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>uniform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.BuildSamples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sampled data set without preparing the probabilities or embedding
if uniform is true, it generate a grid of uniform samples up to 4 angstrom away from
the central atom to generate known-good validation data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.BuildTrain">
<code class="descname">BuildTrain</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>append=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.BuildTrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.BuildTrainMolwise">
<code class="descname">BuildTrainMolwise</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>append=False</em>, <em>MakeDebug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.BuildTrainMolwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates inputs for all training data using the chosen digester.
This version builds all the elements at the same time.
The other version builds each element separately
If PESSamples = [] it may use a Go-model (CITE:http://dx.doi.org/10.1016/S0006-3495(02)75308-3)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.CheckShapes">
<code class="descname">CheckShapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.CheckShapes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.CleanScratch">
<code class="descname">CleanScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.CleanScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.EvaluateTestBatch">
<code class="descname">EvaluateTestBatch</code><span class="sig-paren">(</span><em>desired</em>, <em>predicted</em>, <em>tformer</em>, <em>nmols_=100</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.EvaluateTestBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.GetTestBatch">
<code class="descname">GetTestBatch</code><span class="sig-paren">(</span><em>ncases=1280</em>, <em>ministep=0</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.GetTestBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.GetTrainBatch">
<code class="descname">GetTrainBatch</code><span class="sig-paren">(</span><em>ncases=1280</em>, <em>random=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.GetTrainBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.KRR">
<code class="descname">KRR</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.KRR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.LoadData">
<code class="descname">LoadData</code><span class="sig-paren">(</span><em>random=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.LoadData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.LoadDataToScratch">
<code class="descname">LoadDataToScratch</code><span class="sig-paren">(</span><em>tformer</em>, <em>random=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.LoadDataToScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.LoadElement">
<code class="descname">LoadElement</code><span class="sig-paren">(</span><em>ele</em>, <em>Random=True</em>, <em>DebugData_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.LoadElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.LoadElementToScratch">
<code class="descname">LoadElementToScratch</code><span class="sig-paren">(</span><em>ele</em>, <em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.LoadElementToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.
note that modifies my MolDigester to incorporate the normalization
Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.MergeWith">
<code class="descname">MergeWith</code><span class="sig-paren">(</span><em>ASet_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.MergeWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Augments my training data with another set, which for example may have been generated on another computer.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.NTestCasesInScratch">
<code class="descname">NTestCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.NTestCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.NTrainCasesInScratch">
<code class="descname">NTrainCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.NTrainCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.PrintSampleInformation">
<code class="descname">PrintSampleInformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.PrintSampleInformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.PrintStatus">
<code class="descname">PrintStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.PrintStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.QueryAvailable">
<code class="descname">QueryAvailable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.QueryAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>If Tensordata has already been made, this looks for it under a passed name.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.Randomize">
<code class="descname">Randomize</code><span class="sig-paren">(</span><em>ti</em>, <em>to</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.Randomize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.RawBatch">
<code class="descname">RawBatch</code><span class="sig-paren">(</span><em>nmol=4096</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.RawBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Shimmy Shimmy Ya Shimmy Ya Shimmy Yay.
This type of batch is not built beforehand
because there&#8217;s no real digestion involved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmol</strong> &#8211; number of molecules to put in the output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a #atomsX4 tensor (AtNum,x,y,z)
Outs: output of the digester
Keys: (nmol)X(MaxNAtoms) tensor listing each molecule&#8217;s place in the input.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Ins</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.ReloadSet">
<code class="descname">ReloadSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.ReloadSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalls the MSet to build training data etc.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>MSet</strong> &#8211; A molecule set from which to cull data.</li>
<li><strong>Dig</strong> &#8211; A MolDigester object to create embeddings, and evaluate outputs.</li>
<li><strong>Name</strong> &#8211; A name for this TensorMolData</li>
<li><strong>These parameters should be removed ------------</strong> (<em>#</em>) &#8211; </li>
<li><strong>order</strong> &#8211; Order of many-body expansion to perform.</li>
<li><strong>num_indis</strong> &#8211; Number of Indistinguishable Fragments.</li>
<li><strong>type</strong> &#8211; Whether this TensorMolData is for &#8220;frag&#8221;, &#8220;atom&#8221;, or &#8220;mol&#8221;</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TensorMolData.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TensorMolData'</em><a class="headerlink" href="#TensorMol.TensorMolData.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.TensorMolDataEE">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TensorMolDataEE</code><span class="sig-paren">(</span><em>MSet_</em>, <em>Dig_</em>, <em>Name_</em>, <em>WithGrad_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolDataEE" title="Permalink to this definition">¶</a></dt>
<dd><p>Electrostatically embedded TensorMolData.
This is also a re-write of our BP scheme with TensorFlow&#8217;s
New scatter gather capabilities to reduce padding.</p>
<p>Inputs are xyz, embedding, (emb. derivative)
Outputs are Energy, Dipole (force)</p>
<dl class="method">
<dt id="TensorMol.TensorMolDataEE.BuildTrain">
<code class="descname">BuildTrain</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>append=False</em>, <em>max_nmols_=1000000</em>, <em>WithGrad_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolDataEE.BuildTrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolDataEE.GetTestBatch">
<code class="descname">GetTestBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolDataEE.GetTestBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns:
A an <strong>ordered</strong> list of length self.eles containing</p>
<blockquote>
<div>a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.
the number of output molecules.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolDataEE.GetTrainBatch">
<code class="descname">GetTrainBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolDataEE.GetTrainBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the data required for a training batch Returns inputs (sorted by element), and indexing matrices and outputs.
Behler parinello batches need to have a typical overall stoichiometry.
and a constant number of atoms, and must contain an integer number of molecules.</p>
<p>Besides making sure all of that takes place this routine makes the summation matrices
which map the cases =&gt; molecular energies in the Neural Network output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ncases</strong> &#8211; the size of a training cases.</li>
<li><strong>noutputs</strong> &#8211; the maximum number of molecule energies which can be produced.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>A an <strong>ordered</strong> list of length self.eles containing</dt>
<dd><p class="first last">a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolDataEE.LoadData">
<code class="descname">LoadData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolDataEE.LoadData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolDataEE.LoadDataToScratch">
<code class="descname">LoadDataToScratch</code><span class="sig-paren">(</span><em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolDataEE.LoadDataToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.</p>
<blockquote>
<div>note that modifies my MolDigester to incorporate the normalization</div></blockquote>
<p>Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also determines mean stoichiometry</p>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolDataEE.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>MSet_</em>, <em>Dig_</em>, <em>Name_</em>, <em>WithGrad_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolDataEE.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>MSet should have energies</strong><strong>, </strong><strong>charges and optionally forces.</strong> (<em>The</em>) &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.TensorMolDataEE.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TensorMolDataEE'</em><a class="headerlink" href="#TensorMol.TensorMolDataEE.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.TensorMolData_BP">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TensorMolData_BP</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em>, <em>WithGrad_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TensorMolData.TensorMolData</span></code></p>
<p>A tensordata for molecules and Behler-Parinello.
a Case is an input to the NN.</p>
<dl class="method">
<dt id="TensorMol.TensorMolData_BP.BuildSamples">
<code class="descname">BuildSamples</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>uniform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.BuildSamples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sampled data set without preparing the probabilities or embedding
if uniform is true, it generate a grid of uniform samples up to 4 angstrom away from
the central atom to generate known-good validation data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.BuildTrain">
<code class="descname">BuildTrain</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>append=False</em>, <em>max_nmols_=1000000</em>, <em>WithGrad_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.BuildTrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.BuildTrainMolwise">
<code class="descname">BuildTrainMolwise</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>append=False</em>, <em>MakeDebug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.BuildTrainMolwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates inputs for all training data using the chosen digester.
This version builds all the elements at the same time.
The other version builds each element separately
If PESSamples = [] it may use a Go-model (CITE:http://dx.doi.org/10.1016/S0006-3495(02)75308-3)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.CheckShapes">
<code class="descname">CheckShapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.CheckShapes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.CleanScratch">
<code class="descname">CleanScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.CleanScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.EvaluateTestBatch">
<code class="descname">EvaluateTestBatch</code><span class="sig-paren">(</span><em>desired</em>, <em>predicted</em>, <em>tformer</em>, <em>nmols_=100</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.EvaluateTestBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.GetTestBatch">
<code class="descname">GetTestBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.GetTestBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns:
A an <strong>ordered</strong> list of length self.eles containing</p>
<blockquote>
<div>a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.
the number of output molecules.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.GetTrainBatch">
<code class="descname">GetTrainBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.GetTrainBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the data required for a training batch Returns inputs (sorted by element), and indexing matrices and outputs.
Behler parinello batches need to have a typical overall stoichiometry.
and a constant number of atoms, and must contain an integer number of molecules.
Besides making sure all of that takes place this routine makes the summation matrices
which map the cases =&gt; molecular energies in the Neural Network output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ncases</strong> &#8211; the size of a training cases.</li>
<li><strong>noutputs</strong> &#8211; the maximum number of molecule energies which can be produced.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>A an <strong>ordered</strong> list of length self.eles containing</dt>
<dd><p class="first last">a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.Init_TraceBack">
<code class="descname">Init_TraceBack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.Init_TraceBack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.KRR">
<code class="descname">KRR</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.KRR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.LoadData">
<code class="descname">LoadData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.LoadData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.LoadDataToScratch">
<code class="descname">LoadDataToScratch</code><span class="sig-paren">(</span><em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.LoadDataToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.
note that modifies my MolDigester to incorporate the normalization
Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also determines mean stoichiometry</p>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.LoadElement">
<code class="descname">LoadElement</code><span class="sig-paren">(</span><em>ele</em>, <em>Random=True</em>, <em>DebugData_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.LoadElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.LoadElementToScratch">
<code class="descname">LoadElementToScratch</code><span class="sig-paren">(</span><em>ele</em>, <em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.LoadElementToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.
note that modifies my MolDigester to incorporate the normalization
Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.MergeWith">
<code class="descname">MergeWith</code><span class="sig-paren">(</span><em>ASet_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.MergeWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Augments my training data with another set, which for example may have been generated on another computer.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.NTestCasesInScratch">
<code class="descname">NTestCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.NTestCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.NTrainCasesInScratch">
<code class="descname">NTrainCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.NTrainCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.PrintSampleInformation">
<code class="descname">PrintSampleInformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.PrintSampleInformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.PrintStatus">
<code class="descname">PrintStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.PrintStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.QueryAvailable">
<code class="descname">QueryAvailable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.QueryAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>If Tensordata has already been made, this looks for it under a passed name.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.Randomize">
<code class="descname">Randomize</code><span class="sig-paren">(</span><em>ti</em>, <em>to</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.Randomize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.RawBatch">
<code class="descname">RawBatch</code><span class="sig-paren">(</span><em>nmol=4096</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.RawBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Shimmy Shimmy Ya Shimmy Ya Shimmy Yay.
This type of batch is not built beforehand
because there&#8217;s no real digestion involved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmol</strong> &#8211; number of molecules to put in the output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a #atomsX4 tensor (AtNum,x,y,z)
Outs: output of the digester
Keys: (nmol)X(MaxNAtoms) tensor listing each molecule&#8217;s place in the input.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Ins</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.ReloadSet">
<code class="descname">ReloadSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.ReloadSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalls the MSet to build training data etc.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em>, <em>WithGrad_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TensorMolData_BP.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TensorMolData'</em><a class="headerlink" href="#TensorMol.TensorMolData_BP.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.TensorMolData_BP_Multipole">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TensorMolData_BP_Multipole</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TensorMolData.TensorMolData_BP</span></code></p>
<p>A tensordata for learning the multipole of molecules using Behler-Parinello scheme.</p>
<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.BuildSamples">
<code class="descname">BuildSamples</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>uniform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.BuildSamples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sampled data set without preparing the probabilities or embedding
if uniform is true, it generate a grid of uniform samples up to 4 angstrom away from
the central atom to generate known-good validation data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.BuildTrain">
<code class="descname">BuildTrain</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>append=False</em>, <em>max_nmols_=1000000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.BuildTrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.BuildTrainMolwise">
<code class="descname">BuildTrainMolwise</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>append=False</em>, <em>MakeDebug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.BuildTrainMolwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates inputs for all training data using the chosen digester.
This version builds all the elements at the same time.
The other version builds each element separately
If PESSamples = [] it may use a Go-model (CITE:http://dx.doi.org/10.1016/S0006-3495(02)75308-3)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.CheckShapes">
<code class="descname">CheckShapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.CheckShapes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.CleanScratch">
<code class="descname">CleanScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.CleanScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.EvaluateTestBatch">
<code class="descname">EvaluateTestBatch</code><span class="sig-paren">(</span><em>desired</em>, <em>predicted</em>, <em>tformer</em>, <em>nmols_=100</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.EvaluateTestBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.GetTestBatch">
<code class="descname">GetTestBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.GetTestBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns:
A an <strong>ordered</strong> list of length self.eles containing</p>
<blockquote>
<div>a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.
the number of output molecules.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.GetTrainBatch">
<code class="descname">GetTrainBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.GetTrainBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the data required for a training batch Returns inputs (sorted by element), and indexing matrices and outputs.
Behler parinello batches need to have a typical overall stoichiometry.
and a constant number of atoms, and must contain an integer number of molecules.</p>
<p>Besides making sure all of that takes place this routine makes the summation matrices
which map the cases =&gt; molecular energies in the Neural Network output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ncases</strong> &#8211; the size of a training cases.</li>
<li><strong>noutputs</strong> &#8211; the maximum number of molecule energies which can be produced.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>A an <strong>ordered</strong> list of length self.eles containing</dt>
<dd><p class="first last">a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.Init_TraceBack">
<code class="descname">Init_TraceBack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.Init_TraceBack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.KRR">
<code class="descname">KRR</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.KRR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.LoadData">
<code class="descname">LoadData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.LoadData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.LoadDataToScratch">
<code class="descname">LoadDataToScratch</code><span class="sig-paren">(</span><em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.LoadDataToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.</p>
<blockquote>
<div>note that modifies my MolDigester to incorporate the normalization</div></blockquote>
<p>Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also determines mean stoichiometry</p>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.LoadElement">
<code class="descname">LoadElement</code><span class="sig-paren">(</span><em>ele</em>, <em>Random=True</em>, <em>DebugData_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.LoadElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.LoadElementToScratch">
<code class="descname">LoadElementToScratch</code><span class="sig-paren">(</span><em>ele</em>, <em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.LoadElementToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.
note that modifies my MolDigester to incorporate the normalization
Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.MergeWith">
<code class="descname">MergeWith</code><span class="sig-paren">(</span><em>ASet_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.MergeWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Augments my training data with another set, which for example may have been generated on another computer.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.NTestCasesInScratch">
<code class="descname">NTestCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.NTestCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.NTrainCasesInScratch">
<code class="descname">NTrainCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.NTrainCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.PrintSampleInformation">
<code class="descname">PrintSampleInformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.PrintSampleInformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.PrintStatus">
<code class="descname">PrintStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.PrintStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.QueryAvailable">
<code class="descname">QueryAvailable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.QueryAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>If Tensordata has already been made, this looks for it under a passed name.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.Randomize">
<code class="descname">Randomize</code><span class="sig-paren">(</span><em>ti</em>, <em>to</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.Randomize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.RawBatch">
<code class="descname">RawBatch</code><span class="sig-paren">(</span><em>nmol=4096</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.RawBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Shimmy Shimmy Ya Shimmy Ya Shimmy Yay.
This type of batch is not built beforehand
because there&#8217;s no real digestion involved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmol</strong> &#8211; number of molecules to put in the output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a #atomsX4 tensor (AtNum,x,y,z)
Outs: output of the digester
Keys: (nmol)X(MaxNAtoms) tensor listing each molecule&#8217;s place in the input.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Ins</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.ReloadSet">
<code class="descname">ReloadSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.ReloadSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalls the MSet to build training data etc.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TensorMolData_BP_Multipole.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TensorMolDataEE'</em><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.TensorMolData_BP_Multipole_2">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TensorMolData_BP_Multipole_2</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TensorMolDataEE.TensorMolData_BP_Multipole</span></code></p>
<p>A tensordata for learning the multipole of molecules using Behler-Parinello scheme.</p>
<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.BuildSamples">
<code class="descname">BuildSamples</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>uniform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.BuildSamples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sampled data set without preparing the probabilities or embedding
if uniform is true, it generate a grid of uniform samples up to 4 angstrom away from
the central atom to generate known-good validation data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.BuildTrain">
<code class="descname">BuildTrain</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>append=False</em>, <em>max_nmols_=1000000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.BuildTrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.BuildTrainMolwise">
<code class="descname">BuildTrainMolwise</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>append=False</em>, <em>MakeDebug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.BuildTrainMolwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates inputs for all training data using the chosen digester.
This version builds all the elements at the same time.
The other version builds each element separately
If PESSamples = [] it may use a Go-model (CITE:http://dx.doi.org/10.1016/S0006-3495(02)75308-3)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.CheckShapes">
<code class="descname">CheckShapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.CheckShapes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.CleanScratch">
<code class="descname">CleanScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.CleanScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.EvaluateTestBatch">
<code class="descname">EvaluateTestBatch</code><span class="sig-paren">(</span><em>desired</em>, <em>predicted</em>, <em>tformer</em>, <em>nmols_=100</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.EvaluateTestBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.GetTestBatch">
<code class="descname">GetTestBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.GetTestBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns:
A an <strong>ordered</strong> list of length self.eles containing</p>
<blockquote>
<div>a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.
the number of output molecules.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.GetTrainBatch">
<code class="descname">GetTrainBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.GetTrainBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the data required for a training batch Returns inputs (sorted by element), and indexing matrices and outputs.
Behler parinello batches need to have a typical overall stoichiometry.
and a constant number of atoms, and must contain an integer number of molecules.</p>
<p>Besides making sure all of that takes place this routine makes the summation matrices
which map the cases =&gt; molecular energies in the Neural Network output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ncases</strong> &#8211; the size of a training cases.</li>
<li><strong>noutputs</strong> &#8211; the maximum number of molecule energies which can be produced.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>A an <strong>ordered</strong> list of length self.eles containing</dt>
<dd><p class="first last">a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.Init_TraceBack">
<code class="descname">Init_TraceBack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.Init_TraceBack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.KRR">
<code class="descname">KRR</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.KRR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.LoadData">
<code class="descname">LoadData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.LoadData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.LoadDataToScratch">
<code class="descname">LoadDataToScratch</code><span class="sig-paren">(</span><em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.LoadDataToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.</p>
<blockquote>
<div>note that modifies my MolDigester to incorporate the normalization</div></blockquote>
<p>Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also determines mean stoichiometry</p>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.LoadElement">
<code class="descname">LoadElement</code><span class="sig-paren">(</span><em>ele</em>, <em>Random=True</em>, <em>DebugData_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.LoadElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.LoadElementToScratch">
<code class="descname">LoadElementToScratch</code><span class="sig-paren">(</span><em>ele</em>, <em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.LoadElementToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.
note that modifies my MolDigester to incorporate the normalization
Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.MergeWith">
<code class="descname">MergeWith</code><span class="sig-paren">(</span><em>ASet_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.MergeWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Augments my training data with another set, which for example may have been generated on another computer.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.NTestCasesInScratch">
<code class="descname">NTestCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.NTestCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.NTrainCasesInScratch">
<code class="descname">NTrainCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.NTrainCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.PrintSampleInformation">
<code class="descname">PrintSampleInformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.PrintSampleInformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.PrintStatus">
<code class="descname">PrintStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.PrintStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.QueryAvailable">
<code class="descname">QueryAvailable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.QueryAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>If Tensordata has already been made, this looks for it under a passed name.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.Randomize">
<code class="descname">Randomize</code><span class="sig-paren">(</span><em>ti</em>, <em>to</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.Randomize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.RawBatch">
<code class="descname">RawBatch</code><span class="sig-paren">(</span><em>nmol=4096</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.RawBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Shimmy Shimmy Ya Shimmy Ya Shimmy Yay.
This type of batch is not built beforehand
because there&#8217;s no real digestion involved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmol</strong> &#8211; number of molecules to put in the output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a #atomsX4 tensor (AtNum,x,y,z)
Outs: output of the digester
Keys: (nmol)X(MaxNAtoms) tensor listing each molecule&#8217;s place in the input.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Ins</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.ReloadSet">
<code class="descname">ReloadSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.ReloadSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalls the MSet to build training data etc.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TensorMolData_BP_Multipole_2.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TensorMolDataEE'</em><a class="headerlink" href="#TensorMol.TensorMolData_BP_Multipole_2.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.TensorMolData_Bond_BP">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">TensorMolData_Bond_BP</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">TensorMol.TensorMolData.TensorMolData_BP</span></code></p>
<p>A tensordata for molecules and Bond-wise Behler-Parinello.</p>
<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.BuildSamples">
<code class="descname">BuildSamples</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>uniform=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.BuildSamples" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sampled data set without preparing the probabilities or embedding
if uniform is true, it generate a grid of uniform samples up to 4 angstrom away from
the central atom to generate known-good validation data.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.BuildTrain">
<code class="descname">BuildTrain</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>append=False</em>, <em>max_nmols_=1000000</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.BuildTrain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.BuildTrainMolwise">
<code class="descname">BuildTrainMolwise</code><span class="sig-paren">(</span><em>name_='gdb9'</em>, <em>atypes=[]</em>, <em>append=False</em>, <em>MakeDebug=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.BuildTrainMolwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates inputs for all training data using the chosen digester.
This version builds all the elements at the same time.
The other version builds each element separately
If PESSamples = [] it may use a Go-model (CITE:http://dx.doi.org/10.1016/S0006-3495(02)75308-3)</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.CheckShapes">
<code class="descname">CheckShapes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.CheckShapes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.CleanScratch">
<code class="descname">CleanScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.CleanScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.EvaluateTestBatch">
<code class="descname">EvaluateTestBatch</code><span class="sig-paren">(</span><em>desired</em>, <em>predicted</em>, <em>tformer</em>, <em>nmols_=100</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.EvaluateTestBatch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.GetTestBatch">
<code class="descname">GetTestBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.GetTestBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns:
A an <strong>ordered</strong> list of length self.eles containing</p>
<blockquote>
<div>a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.
the number of output molecules.</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.GetTrainBatch">
<code class="descname">GetTrainBatch</code><span class="sig-paren">(</span><em>ncases</em>, <em>noutputs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.GetTrainBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct the data required for a training batch Returns inputs (sorted by element), and indexing matrices and outputs.
Behler parinello batches need to have a typical overall stoichiometry.
and a constant number of atoms, and must contain an integer number of molecules.
Besides making sure all of that takes place this routine makes the summation matrices
which map the cases =&gt; molecular energies in the Neural Network output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>ncases</strong> &#8211; the size of a training cases.</li>
<li><strong>noutputs</strong> &#8211; the maximum number of molecule energies which can be produced.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>A an <strong>ordered</strong> list of length self.eles containing</dt>
<dd><p class="first last">a list of (num_of atom type X flattened input shape) matrix of input cases.
a list of (num_of atom type X batchsize) matrices which linearly combines the elements
a list of outputs.</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.Init_TraceBack">
<code class="descname">Init_TraceBack</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.Init_TraceBack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.KRR">
<code class="descname">KRR</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.KRR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.Load">
<code class="descname">Load</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.Load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.LoadData">
<code class="descname">LoadData</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.LoadData" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.LoadDataToScratch">
<code class="descname">LoadDataToScratch</code><span class="sig-paren">(</span><em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.LoadDataToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.
note that modifies my MolDigester to incorporate the normalization
Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also determines mean stoichiometry</p>
</div>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.LoadElement">
<code class="descname">LoadElement</code><span class="sig-paren">(</span><em>ele</em>, <em>Random=True</em>, <em>DebugData_=False</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.LoadElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.LoadElementToScratch">
<code class="descname">LoadElementToScratch</code><span class="sig-paren">(</span><em>ele</em>, <em>tformer</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.LoadElementToScratch" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads built training data off disk into scratch space.
Divides training and test data.
Normalizes inputs and outputs.
note that modifies my MolDigester to incorporate the normalization
Initializes pointers used to provide training batches.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random</strong> &#8211; Not yet implemented randomization of the read data.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.MergeWith">
<code class="descname">MergeWith</code><span class="sig-paren">(</span><em>ASet_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.MergeWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Augments my training data with another set, which for example may have been generated on another computer.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.NTestCasesInScratch">
<code class="descname">NTestCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.NTestCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.NTrainCasesInScratch">
<code class="descname">NTrainCasesInScratch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.NTrainCasesInScratch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.PrintSampleInformation">
<code class="descname">PrintSampleInformation</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.PrintSampleInformation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.PrintStatus">
<code class="descname">PrintStatus</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.PrintStatus" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.QueryAvailable">
<code class="descname">QueryAvailable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.QueryAvailable" title="Permalink to this definition">¶</a></dt>
<dd><p>If Tensordata has already been made, this looks for it under a passed name.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.Randomize">
<code class="descname">Randomize</code><span class="sig-paren">(</span><em>ti</em>, <em>to</em>, <em>group</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.Randomize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.RawBatch">
<code class="descname">RawBatch</code><span class="sig-paren">(</span><em>nmol=4096</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.RawBatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Shimmy Shimmy Ya Shimmy Ya Shimmy Yay.
This type of batch is not built beforehand
because there&#8217;s no real digestion involved.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmol</strong> &#8211; number of molecules to put in the output.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a #atomsX4 tensor (AtNum,x,y,z)
Outs: output of the digester
Keys: (nmol)X(MaxNAtoms) tensor listing each molecule&#8217;s place in the input.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Ins</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.ReloadSet">
<code class="descname">ReloadSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.ReloadSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalls the MSet to build training data etc.</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.Save">
<code class="descname">Save</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.Save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.TensorMolData_Bond_BP.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>MSet_=None</em>, <em>Dig_=None</em>, <em>Name_=None</em>, <em>order_=3</em>, <em>num_indis_=1</em>, <em>type_='mol'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="TensorMol.TensorMolData_Bond_BP.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.TensorMolData'</em><a class="headerlink" href="#TensorMol.TensorMolData_Bond_BP.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.TestCoulomb">
<code class="descclassname">TensorMol.</code><code class="descname">TestCoulomb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TestCoulomb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.TestLJ">
<code class="descclassname">TensorMol.</code><code class="descname">TestLJ</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.TestLJ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="TensorMol.Thermostat">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Thermostat</code><span class="sig-paren">(</span><em>m_</em>, <em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Thermostat" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.Thermostat.Rescale">
<code class="descname">Rescale</code><span class="sig-paren">(</span><em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Thermostat.Rescale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Thermostat.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>m_</em>, <em>v_</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Thermostat.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Velocity Verlet step with a Rescaling Thermostat</p>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.Thermostat.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.SimpleMD'</em><a class="headerlink" href="#TensorMol.Thermostat.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Thermostat.step">
<code class="descname">step</code><span class="sig-paren">(</span><em>f_</em>, <em>a_</em>, <em>x_</em>, <em>v_</em>, <em>m_</em>, <em>dt_</em>, <em>fande_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Thermostat.step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.Transformer">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">Transformer</code><span class="sig-paren">(</span><em>InNorm_=None</em>, <em>OutNorm_=None</em>, <em>ele_=None</em>, <em>Emb_=None</em>, <em>OType_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer" title="Permalink to this definition">¶</a></dt>
<dd><p>Data manipulation routines for normalizing and other transformations to the
embedding and learning targets. TensorData initializes the transformer
automatically if a .tdt file is loaded for training. The choice of transformation
routines are set by PARAMS[&#8220;InNormRoutine&#8221;] and PARAMS[&#8220;OutNormRoutine&#8221;].</p>
<dl class="method">
<dt id="TensorMol.Transformer.AssignInMeanStd">
<code class="descname">AssignInMeanStd</code><span class="sig-paren">(</span><em>ins</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.AssignInMeanStd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.AssignOutMeanStd">
<code class="descname">AssignOutMeanStd</code><span class="sig-paren">(</span><em>outs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.AssignOutMeanStd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.NormInFrobenius">
<code class="descname">NormInFrobenius</code><span class="sig-paren">(</span><em>ins</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.NormInFrobenius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.NormInMeanStd">
<code class="descname">NormInMeanStd</code><span class="sig-paren">(</span><em>ins</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.NormInMeanStd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.NormOutLogarithmic">
<code class="descname">NormOutLogarithmic</code><span class="sig-paren">(</span><em>outs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.NormOutLogarithmic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.NormOutMeanStd">
<code class="descname">NormOutMeanStd</code><span class="sig-paren">(</span><em>outs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.NormOutMeanStd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.NormOutSign">
<code class="descname">NormOutSign</code><span class="sig-paren">(</span><em>outs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.NormOutSign" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.NormalizeIns">
<code class="descname">NormalizeIns</code><span class="sig-paren">(</span><em>ins</em>, <em>train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.NormalizeIns" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.NormalizeOuts">
<code class="descname">NormalizeOuts</code><span class="sig-paren">(</span><em>outs</em>, <em>train=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.NormalizeOuts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.Print">
<code class="descname">Print</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.Print" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.UnNormOutLogarithmic">
<code class="descname">UnNormOutLogarithmic</code><span class="sig-paren">(</span><em>outs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.UnNormOutLogarithmic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.UnNormOutMeanStd">
<code class="descname">UnNormOutMeanStd</code><span class="sig-paren">(</span><em>outs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.UnNormOutMeanStd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.UnNormalizeOuts">
<code class="descname">UnNormalizeOuts</code><span class="sig-paren">(</span><em>outs</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.UnNormalizeOuts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.Transformer.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>InNorm_=None</em>, <em>OutNorm_=None</em>, <em>ele_=None</em>, <em>Emb_=None</em>, <em>OType_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.Transformer.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>InNorm</strong> &#8211; Embedding normalization type</li>
<li><strong>OutNorm</strong> &#8211; Learning target normalization type</li>
<li><strong>ele</strong> &#8211; Element type for this transformer</li>
<li><strong>Emb</strong> &#8211; Type of digester to reduce molecules to NN inputs.</li>
<li><strong>OType</strong> &#8211; Property of the molecule which will be learned (energy, force, etc)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.Transformer.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.Transformer'</em><a class="headerlink" href="#TensorMol.Transformer.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="TensorMol.VelocityVerlet">
<em class="property">class </em><code class="descclassname">TensorMol.</code><code class="descname">VelocityVerlet</code><span class="sig-paren">(</span><em>f_</em>, <em>g0_</em>, <em>name_=''</em>, <em>EandF_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.VelocityVerlet" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="TensorMol.VelocityVerlet.Prop">
<code class="descname">Prop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.VelocityVerlet.Prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagate VelocityVerlet</p>
</dd></dl>

<dl class="method">
<dt id="TensorMol.VelocityVerlet.WriteTrajectory">
<code class="descname">WriteTrajectory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.VelocityVerlet.WriteTrajectory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="TensorMol.VelocityVerlet.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>f_</em>, <em>g0_</em>, <em>name_=''</em>, <em>EandF_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.VelocityVerlet.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Molecular dynamics</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>f</strong> &#8211; a force routine</li>
<li><strong>g0</strong> &#8211; initial molecule.</li>
<li><strong>EandF</strong> &#8211; An energy,force routine.</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDMaxStep&quot;</strong><strong>]</strong><strong></strong> &#8211; Number of steps to take.</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDTemp&quot;</strong><strong>]</strong><strong></strong> &#8211; Temperature to initialize or Thermostat to.</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDdt&quot;</strong><strong>]</strong><strong></strong> &#8211; Timestep.</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDV0&quot;</strong><strong>]</strong><strong></strong> &#8211; Sort of velocity initialization (None, or &#8220;Random&#8221;)</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;MDLogTrajectory&quot;</strong><strong>]</strong><strong></strong> &#8211; Write MD Trajectory.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A reaction path.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="TensorMol.VelocityVerlet.__module__">
<code class="descname">__module__</code><em class="property"> = 'TensorMol.SimpleMD'</em><a class="headerlink" href="#TensorMol.VelocityVerlet.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="TensorMol.VelocityVerletstep">
<code class="descclassname">TensorMol.</code><code class="descname">VelocityVerletstep</code><span class="sig-paren">(</span><em>f_</em>, <em>a_</em>, <em>x_</em>, <em>v_</em>, <em>m_</em>, <em>dt_</em>, <em>fande_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.VelocityVerletstep" title="Permalink to this definition">¶</a></dt>
<dd><p>A Velocity Verlet Step</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> &#8211; The force function (returns Joules/Angstrom)</li>
<li><strong>a</strong> &#8211; The acceleration at current step. (A^2/fs^2)</li>
<li><strong>x</strong> &#8211; Current coordinates (A)</li>
<li><strong>v</strong> &#8211; Velocities (A/fs)</li>
<li><strong>m</strong> &#8211; the mass vector. (kg)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.WeightedCoordAverage">
<code class="descclassname">TensorMol.</code><code class="descname">WeightedCoordAverage</code><span class="sig-paren">(</span><em>x_</em>, <em>q_</em>, <em>center_=None</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.WeightedCoordAverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Dipole relative to center of <a href="#id69"><span class="problematic" id="id70">x_</span></a></p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.WriteDerDipoleCorrelationFunction">
<code class="descclassname">TensorMol.</code><code class="descname">WriteDerDipoleCorrelationFunction</code><span class="sig-paren">(</span><em>MuTraj</em>, <em>name_='MutMu0.txt'</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.WriteDerDipoleCorrelationFunction" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd>time, mux, muy, muz ...</dd>
</dl>
<p>Returns: sum_i langle dot{mu_i(t)}cdot dot{mu_i(0)}</p>
</div></blockquote>
<p>angle</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.WriteDipoleCorrelationFunction">
<code class="descclassname">TensorMol.</code><code class="descname">WriteDipoleCorrelationFunction</code><span class="sig-paren">(</span><em>t0</em>, <em>t1</em>, <em>t2</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.WriteDipoleCorrelationFunction" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><dl class="docutils">
<dt>Args:</dt>
<dd>time, mux, muy, muz ...</dd>
</dl>
<p>Returns: sum_i langle mu_i(t)cdot mu_i(0)</p>
</div></blockquote>
<p>angle</p>
</dd></dl>

<dl class="function">
<dt id="TensorMol.WriteVelocityAutocorrelations">
<code class="descclassname">TensorMol.</code><code class="descname">WriteVelocityAutocorrelations</code><span class="sig-paren">(</span><em>muhis</em>, <em>vhis</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.WriteVelocityAutocorrelations" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>velocity autocorrelation functions.</strong> (<em>Generate</em>) &#8211; </td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.XyzsToCoulomb">
<code class="descclassname">TensorMol.</code><code class="descname">XyzsToCoulomb</code><span class="sig-paren">(</span><em>xyz_pl</em>, <em>q_pl</em>, <em>Long=True</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.XyzsToCoulomb" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>version is quadratic</strong> (<em>This</em>) &#8211; </li>
<li><strong>be used for training purposes.</strong> (<em>only</em>) &#8211; </li>
<li><strong>xyz_pl</strong> &#8211; a NMol, Natom X 3 tensor of coordinates.</li>
<li><strong>q_pl</strong> &#8211; an NMol X Natom X 1 tensor of atomic charges.</li>
<li><strong>Long</strong> &#8211; Whether to use long-rage or short-range kernel.</li>
<li><strong>PARAMS</strong><strong>[</strong><strong>&quot;EESwitchFunc&quot;</strong><strong>]</strong><strong></strong> &#8211; The Kernel type
None =&gt; 1/r, bare Coulomb
&#8216;Cos&#8217; =&gt; 1/r -&gt; (1.-0.5*(cos(PI*r/EECutoff)+1))/r (if r&lt;Cutoff else 0)
&#8216;Tanh&#8217; =&gt; 1/r =&gt; 0.5*(Tanh[(x - EECutoff)/EEdr] + 1)/r</li>
<li><strong>Returns</strong> &#8211; E mol = sum_{atom1,atom2,cart} q_1*q_2*Kernel(sqrt(pow(atom1_cart - atom2_cart,2.0)))</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="TensorMol.complement">
<code class="descclassname">TensorMol.</code><code class="descname">complement</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.complement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.exitTensorMol">
<code class="descclassname">TensorMol.</code><code class="descname">exitTensorMol</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.exitTensorMol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.inline">
<code class="descclassname">TensorMol.</code><code class="descname">inline</code><span class="sig-paren">(</span><em>code</em>, <em>arg_names=[]</em>, <em>local_dict=None</em>, <em>global_dict=None</em>, <em>force=0</em>, <em>compiler=''</em>, <em>verbose=0</em>, <em>support_code=None</em>, <em>headers=[]</em>, <em>customize=None</em>, <em>type_converters=None</em>, <em>auto_downcast=1</em>, <em>newarr_converter=0</em>, <em>**kw</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.inline" title="Permalink to this definition">¶</a></dt>
<dd><p>Inline C/C++ code within Python scripts.</p>
<p><code class="docutils literal"><span class="pre">inline()</span></code> compiles and executes C/C++ code on the fly.  Variables
in the local and global Python scope are also available in the
C/C++ code.  Values are passed to the C/C++ code by assignment
much like variables passed are passed into a standard Python
function.  Values are returned from the C/C++ code through a
special argument called return_val.  Also, the contents of
mutable objects can be changed within the C/C++ code and the
changes remain after the C code exits and returns to Python.</p>
<p>inline has quite a few options as listed below.  Also, the keyword
arguments for distutils extension modules are accepted to
specify extra information needed for compiling.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>code</strong> (<em>string</em>) &#8211; A string of valid C++ code.  It should not specify a return
statement.  Instead it should assign results that need to be
returned to Python in the <cite>return_val</cite>.</li>
<li><strong>arg_names</strong> (<em></em><em>[</em><em>str</em><em>]</em><em></em><em>, </em><em>optional</em>) &#8211; A list of Python variable names that should be transferred from
Python into the C/C++ code.  It defaults to an empty string.</li>
<li><strong>local_dict</strong> (<em>dict</em><em>, </em><em>optional</em>) &#8211; If specified, it is a dictionary of values that should be used as
the local scope for the C/C++ code.  If local_dict is not
specified the local dictionary of the calling function is used.</li>
<li><strong>global_dict</strong> (<em>dict</em><em>, </em><em>optional</em>) &#8211; If specified, it is a dictionary of values that should be used as
the global scope for the C/C++ code.  If <cite>global_dict</cite> is not
specified, the global dictionary of the calling function is used.</li>
<li><strong>force</strong> (<em>{0</em><em>, </em><em>1}</em><em>, </em><em>optional</em>) &#8211; If 1, the C++ code is compiled every time inline is called.  This
is really only useful for debugging, and probably only useful if
your editing <cite>support_code</cite> a lot.</li>
<li><strong>compiler</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; <p>The name of compiler to use when compiling.  On windows, it
understands &#8216;msvc&#8217; and &#8216;gcc&#8217; as well as all the compiler names
understood by distutils.  On Unix, it&#8217;ll only understand the
values understood by distutils. (I should add &#8216;gcc&#8217; though to
this).</p>
<p>On windows, the compiler defaults to the Microsoft C++ compiler.
If this isn&#8217;t available, it looks for mingw32 (the gcc compiler).</p>
<p>On Unix, it&#8217;ll probably use the same compiler that was used when
compiling Python. Cygwin&#8217;s behavior should be similar.</p>
</li>
<li><strong>verbose</strong> (<em>{0</em><em>,</em><em>1</em><em>,</em><em>2}</em><em>, </em><em>optional</em>) &#8211; Speficies how much much information is printed during the compile
phase of inlining code.  0 is silent (except on windows with msvc
where it still prints some garbage). 1 informs you when compiling
starts, finishes, and how long it took.  2 prints out the command
lines for the compilation process and can be useful if your having
problems getting code to work.  Its handy for finding the name of
the .cpp file if you need to examine it.  verbose has no affect if
the compilation isn&#8217;t necessary.</li>
<li><strong>support_code</strong> (<em>str</em><em>, </em><em>optional</em>) &#8211; A string of valid C++ code declaring extra code that might be
needed by your compiled function.  This could be declarations of
functions, classes, or structures.</li>
<li><strong>headers</strong> (<em></em><em>[</em><em>str</em><em>]</em><em></em><em>, </em><em>optional</em>) &#8211; A list of strings specifying header files to use when compiling
the code.  The list might look like <code class="docutils literal"><span class="pre">[&quot;&lt;vector&gt;&quot;,&quot;'my_header'&quot;]</span></code>.
Note that the header strings need to be in a form than can be
pasted at the end of a <code class="docutils literal"><span class="pre">#include</span></code> statement in the C++ code.</li>
<li><strong>customize</strong> (<em>base_info.custom_info</em><em>, </em><em>optional</em>) &#8211; An alternative way to specify <cite>support_code</cite>, <cite>headers</cite>, etc. needed
by the function.  See <code class="xref py py-mod docutils literal"><span class="pre">scipy.weave.base_info</span></code> for more
details. (not sure this&#8217;ll be used much).</li>
<li><strong>type_converters</strong> (<em></em><em>[</em><em>type converters</em><em>]</em><em></em><em>, </em><em>optional</em>) &#8211; These guys are what convert Python data types to C/C++ data types.
If you&#8217;d like to use a different set of type conversions than the
default, specify them here. Look in the type conversions section
of the main documentation for examples.</li>
<li><strong>auto_downcast</strong> (<em>{1</em><em>,</em><em>0}</em><em>, </em><em>optional</em>) &#8211; This only affects functions that have numpy arrays as input
variables.  Setting this to 1 will cause all floating point values
to be cast as float instead of double if all the Numeric arrays
are of type float.  If even one of the arrays has type double or
double complex, all variables maintain there standard
types.</li>
<li><strong>newarr_converter</strong> (<em>int</em><em>, </em><em>optional</em>) &#8211; Unused.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Other Parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first last">
<li><p class="first"><strong>Relevant :mod:`distutils` keywords.  These are duplicated from Greg Ward&#8217;s</strong></p>
</li>
<li><p class="first"><strong>:class:`distutils.extension.Extension` class for convenience</strong></p>
</li>
<li><p class="first"><strong>sources</strong> (<em>[string]</em>) &#8211; list of source filenames, relative to the distribution root
(where the setup script lives), in Unix form (slash-separated)
for portability.    Source files may be C, C++, SWIG (.i),
platform-specific resource files, or whatever else is recognized
by the &#8220;build_ext&#8221; command as source for a Python extension.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <cite>module_path</cite> file is always appended to the front of
this list</p>
</div>
</li>
<li><p class="first"><strong>include_dirs</strong> (<em>[string]</em>) &#8211; list of directories to search for C/C++ header files (in Unix
form for portability)</p>
</li>
<li><p class="first"><strong>define_macros</strong> (<em>[(name : string, value : string|None)]</em>) &#8211; list of macros to define; each macro is defined using a 2-tuple,
where &#8216;value&#8217; is either the string to define it to or None to
define it without a particular value (equivalent of &#8220;#define
FOO&#8221; in source or -DFOO on Unix C compiler command line)</p>
</li>
<li><p class="first"><strong>undef_macros</strong> (<em>[string]</em>) &#8211; list of macros to undefine explicitly</p>
</li>
<li><p class="first"><strong>library_dirs</strong> (<em>[string]</em>) &#8211; list of directories to search for C/C++ libraries at link time</p>
</li>
<li><p class="first"><strong>libraries</strong> (<em>[string]</em>) &#8211; list of library names (not filenames or paths) to link against</p>
</li>
<li><p class="first"><strong>runtime_library_dirs</strong> (<em>[string]</em>) &#8211; list of directories to search for C/C++ libraries at run time
(for shared extensions, this is when the extension is loaded)</p>
</li>
<li><p class="first"><strong>extra_objects</strong> (<em>[string]</em>) &#8211; list of extra files to link with (eg. object files not implied
by &#8216;sources&#8217;, static library that must be explicitly specified,
binary resource files, etc.)</p>
</li>
<li><p class="first"><strong>extra_compile_args</strong> (<em>[string]</em>) &#8211; any extra platform- and compiler-specific information to use
when compiling the source files in &#8216;sources&#8217;.    For platforms and
compilers where &#8220;command line&#8221; makes sense, this is typically a
list of command-line arguments, but for other platforms it could
be anything.</p>
</li>
<li><p class="first"><strong>extra_link_args</strong> (<em>[string]</em>) &#8211; any extra platform- and compiler-specific information to use
when linking object files together to create the extension (or
to create a new static Python interpreter).    Similar
interpretation as for &#8216;extra_compile_args&#8217;.</p>
</li>
<li><p class="first"><strong>export_symbols</strong> (<em>[string]</em>) &#8211; list of symbols to be exported from a shared extension.    Not
used on all platforms, and not generally necessary for Python
extensions, which typically export exactly one symbol: &#8220;init&#8221; +
extension_name.</p>
</li>
<li><p class="first"><strong>swig_opts</strong> (<em>[string]</em>) &#8211; any extra options to pass to SWIG if a source file has the .i
extension.</p>
</li>
<li><p class="first"><strong>depends</strong> (<em>[string]</em>) &#8211; list of files that the extension depends on</p>
</li>
<li><p class="first"><strong>language</strong> (<em>string</em>) &#8211; extension language (i.e. &#8220;c&#8221;, &#8220;c++&#8221;, &#8220;objc&#8221;). Will be detected
from the source extensions if not provided.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal"><span class="pre">distutils.extension.Extension()</span></code></dt>
<dd>Describes additional parameters.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="TensorMol.iter_product">
<code class="descclassname">TensorMol.</code><code class="descname">iter_product</code><span class="sig-paren">(</span><em>args</em>, <em>repeat=1</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.iter_product" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.nCr">
<code class="descclassname">TensorMol.</code><code class="descname">nCr</code><span class="sig-paren">(</span><em>n</em>, <em>r</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.nCr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="TensorMol.scitodeci">
<code class="descclassname">TensorMol.</code><code class="descname">scitodeci</code><span class="sig-paren">(</span><em>sci</em><span class="sig-paren">)</span><a class="headerlink" href="#TensorMol.scitodeci" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<span class="target" id="module-MolEmb"></span><dl class="function">
<dt id="MolEmb.Make_ANI1_Sym">
<code class="descclassname">MolEmb.</code><code class="descname">Make_ANI1_Sym</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_ANI1_Sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_ANI1_Sym method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_ANI1_Sym_deri">
<code class="descclassname">MolEmb.</code><code class="descname">Make_ANI1_Sym_deri</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_ANI1_Sym_deri" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_ANI1_Sym_deri method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_CM">
<code class="descclassname">MolEmb.</code><code class="descname">Make_CM</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_CM" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_CM method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_CM_vary_coords">
<code class="descclassname">MolEmb.</code><code class="descname">Make_CM_vary_coords</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_CM_vary_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_CM_vary_coords method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_DistMat">
<code class="descclassname">MolEmb.</code><code class="descname">Make_DistMat</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_DistMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_DistMat method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_Go">
<code class="descclassname">MolEmb.</code><code class="descname">Make_Go</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_Go" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_Go method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_GoForce">
<code class="descclassname">MolEmb.</code><code class="descname">Make_GoForce</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_GoForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_GoForce method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_GoForceLocal">
<code class="descclassname">MolEmb.</code><code class="descname">Make_GoForceLocal</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_GoForceLocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_GoForceLocal method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_GoHess">
<code class="descclassname">MolEmb.</code><code class="descname">Make_GoHess</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_GoHess" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_GoHess method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_Inv">
<code class="descclassname">MolEmb.</code><code class="descname">Make_Inv</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_Inv" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_Inv method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_LJForce">
<code class="descclassname">MolEmb.</code><code class="descname">Make_LJForce</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_LJForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_LJForce method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_PGaussian">
<code class="descclassname">MolEmb.</code><code class="descname">Make_PGaussian</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_PGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_PGaussian method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_RDF">
<code class="descclassname">MolEmb.</code><code class="descname">Make_RDF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_RDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_RDF method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_SH">
<code class="descclassname">MolEmb.</code><code class="descname">Make_SH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_SH" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_SH method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_SH_Transf">
<code class="descclassname">MolEmb.</code><code class="descname">Make_SH_Transf</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_SH_Transf" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_SH_Transf method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_Sym">
<code class="descclassname">MolEmb.</code><code class="descname">Make_Sym</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_Sym" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_Sym method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Make_Sym_Update">
<code class="descclassname">MolEmb.</code><code class="descname">Make_Sym_Update</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Make_Sym_Update" title="Permalink to this definition">¶</a></dt>
<dd><p>Make_Sym_Update method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Norm_Matrices">
<code class="descclassname">MolEmb.</code><code class="descname">Norm_Matrices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Norm_Matrices" title="Permalink to this definition">¶</a></dt>
<dd><p>Norm_Matrices method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Overlap_RBF">
<code class="descclassname">MolEmb.</code><code class="descname">Overlap_RBF</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Overlap_RBF" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlap_RBF method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Overlap_RBFS">
<code class="descclassname">MolEmb.</code><code class="descname">Overlap_RBFS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Overlap_RBFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlap_RBFS method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Overlap_SH">
<code class="descclassname">MolEmb.</code><code class="descname">Overlap_SH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Overlap_SH" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlap_SH method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Project_SH">
<code class="descclassname">MolEmb.</code><code class="descname">Project_SH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Project_SH" title="Permalink to this definition">¶</a></dt>
<dd><p>Project_SH method</p>
</dd></dl>

<dl class="function">
<dt id="MolEmb.Raster_SH">
<code class="descclassname">MolEmb.</code><code class="descname">Raster_SH</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#MolEmb.Raster_SH" title="Permalink to this definition">¶</a></dt>
<dd><p>Raster_SH method</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">TensorMol package</a><ul>
<li><a class="reference internal" href="#module-TensorMol">Module contents</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">TensorMol</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/TensorMol.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016, K. Yao, J. E. Herr, J. Parkhill.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/TensorMol.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>